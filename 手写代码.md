# 手写代码篇

## 生产者消费者模式

在线程世界里，**生产者就是生产数据的线程，消费者就是消费数据的线程**。 

在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps13.png?token=ARFL34FWKT3Z6LMTOYQLHFLI562HK) 

当缓冲区满的时候，生产者停止执行，让其他线程进行

当缓冲区空的时候，消费者停止执行，让其他线程执行

当生产者向缓冲区放入一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态；

当消费者从缓冲区取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态

**等待通知机制wait/notify/notifyAll**

![image-20250310233338783](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250310233338783-4133580.png?token=ARFL34F5EVRJJGGGSOMZWMDI562HK)

- `wait` - `wait` 会自动**释放当前线程占有的对象锁**，并请求操作系统挂起当前线程，**让线程从 `Running` 状态转入 `Waiting` 状态**，等待 `notify` / `notifyAll` 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 `notify` 或者 `notifyAll` 来唤醒挂起的线程，造成死锁。
- `notify` - 唤醒一个正在 `Waiting` 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 
- `notifyAll` - 唤醒所有正在 `Waiting` 状态的线程，接下来它们需要竞争对象锁。



- **`wait`、`notify`、`notifyAll` 都是 `Object` 类中的方法**，而非 `Thread`。
- **`wait`、`notify`、`notifyAll` 只能用在 `synchronized` 方法或者 `synchronized` 代码块中使用，否则会在运行时抛出 `IllegalMonitorStateException`**。
- **wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。**

**为什么 `wait`、`notify`、`notifyAll` 不定义在 `Thread` 中？为什么 `wait`、`notify`、`notifyAll` 要配合 `synchronized` 使用？**

首先，需要了解几个基本知识点：

- 每一个 Java 对象都有一个与之对应的 **监视器（monitor）**
- 每一个监视器里面都有一个 **对象锁** 、一个 **等待队列**、一个 **同步队列**

了解了以上概念，我们回过头来理解前面两个问题。

**为什么这几个方法不定义在 `Thread` 中？**

- 由于**每个对象都拥有对象锁**，让当前线程等待某个对象锁，自然应该基于这个对象（`Object`）来操作，而非使用当前线程（`Thread`）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（`Thread`）来操作，就非常复杂了。

**为什么 `wait`、`notify`、`notifyAll` 要配合 `synchronized` 使用？**

- 如果调用某个对象的 `wait` 方法，当前线程必须拥有这个对象的对象锁，因此调用 `wait` 方法必须在 `synchronized` 方法和 `synchronized` 代码块中，如果没有获取到锁前调用wait()方法，会抛出java.lang.IllegalMonitorStateException异常。

![image-20250409013043263](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409013043263.png?token=ARFL34FIFAQDUSTAKK7FLSDI562HI)

![image-20250409013058767](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409013058767.png?token=ARFL34BM4T5QHZFFM4LQFP3I562HK)

![image-20250409013131548](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409013131548.png)

```java
 public class ThreadWaitNotifyDemo02 {
 
     private static final int QUEUE_SIZE = 10;
     private static final PriorityQueue<Integer> queue = new PriorityQueue<>(QUEUE_SIZE);
 
     public static void main(String[] args) {
         new Producer("生产者A").start();
         new Producer("生产者B").start();
         new Consumer("消费者A").start();
         new Consumer("消费者B").start();
     }
 
     static class Consumer extends Thread {
         Consumer(String name) {
             super(name);
         }
         @Override
         public void run() {
             while (true) {
                 synchronized (queue) {
                     while (queue.size() == 0) {
                         try {
                             System.out.println("队列空，等待数据");
                             queue.wait();
                         } catch (InterruptedException e) {
                             e.printStackTrace();
                             queue.notifyAll();
                         }
                     }
                     queue.poll(); // 每次移走队首元素
                     queue.notifyAll();
                     try {
                         Thread.sleep(500);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                     System.out.println(Thread.currentThread().getName() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");
                 }
             }
         }
     }
 
     static class Producer extends Thread {
 
         Producer(String name) {
             super(name);
         }
 
         @Override
         public void run() {
             while (true) {
                 synchronized (queue) {
                     while (queue.size() == QUEUE_SIZE) {
                         try {
                             System.out.println("队列满，等待有空余空间");
                             queue.wait();
                         } catch (InterruptedException e) {
                             e.printStackTrace();
                             queue.notifyAll();
                         }
                     }
                     queue.offer(1); // 每次插入一个元素
                     queue.notifyAll();
                     try {
                         Thread.sleep(500);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                     System.out.println(Thread.currentThread().getName() + " 向队列取中插入一个元素，队列当前有：" + queue.size() + "个元素");
                 }
             }
         }
     }
 }
```

## 手写单例（singleton）设计模式

![image-20250409002955025](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409002955025.png?token=ARFL34D547RFRN5ZB5ADE2TI562HM)

**单例模式的优点：**

​	由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决

**饿汉式**：坏处:对象加载时间过长;好处:饿汉式是线程安全的。

**懒汉式**：好处:延迟对象的创建;坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改

![image-20250409002716615](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409002716615.png)

### 饿汉式

坏处:对象加载时间过长;好处:饿汉式是线程安全的。

![image-20250409002741419](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409002741419.png?token=ARFL34BPBCI7L4O62QZD7CLI562HO)

### 懒汉式

好处:延迟对象的创建;坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps15-4133580.jpg?token=ARFL34GJAUTA2U5PQ5PKV7TI562HO)

### 单例模式之懒汉式（双重校验锁）

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps16.jpg?token=ARFL34HW3IMG3VB323XIOT3I562HO) 

假设有两个线程a和b调用getInstance()方法，假设a先走，一路走到4这一步，执行instance = new Singleton()这句代码

这里如果变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：

![image-20250409003110512](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409003110512.png?token=ARFL34HG72W4AAXAMPLN55LI562HQ)

​	此时，线程b刚刚进来执行到1（看上面的代码块），就有可能会看到instance不为null，然后线程b也就不会等待监视器锁，而是直接返回instance。问题是这个instance可能还没执行完构造方法（线程a此时还在4这一步），所以**线程b拿到的instance是不完整的**，**它里面的属性值可能是初始化的零值(0/false/null)，而不是线程a在构造方法中指定的值**。

### 反射破解单例模式

以上五种单例模式的实现方式中，前四种方式都是不太安全的，饿汉、懒汉、双重检查锁、静态内部类这四种方式都可以使用反射进行破解

![img](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/wps17-4133580.jpg) 

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps18-4133580.jpg?token=ARFL34CLGE4CBGALNVYHAYLI562HS) 

源码中我们可以看见这么一句话，如果你的这个类型是枚举类型，想要通过反射去创建对象时会抛出一个异常（不能通过反射创建枚举对象）

## 多个线程顺序执行问题

### 三个线程分别打印A，B，C

要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串

**【利用synchronized+wait()/notify()】**

​	**思路**：用对象监视器来实现，通过wait和notify()方法来实现等待、通知的逻辑，A执行后，唤醒B，B执行后唤醒C，C执行后再唤醒A，这样循环的等待、唤醒来达到目的。使用一个取模的判断逻辑C%M ==N，题为3个线程，所以可以按取模结果编号：0、1、2，他们与3取模结果仍为本身，则执行打印逻辑。

**state是volatile注意！！**

- **`Object.wait()` 方法可能因系统中断或其他原因提前返回（虚假唤醒），此时线程需要重新检查条件是否满足。**

![image-20250409003447207](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409003447207.png?token=ARFL34DDM43AXMYK6SRNJFTI562HS)

![image-20250409003515747](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409003515747.png?token=ARFL34BFOQKVG2HECUY2EEDI562HU)

![image-20250409003519564](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409003519564.png)

### 两个线程交替打印奇数和偶数

- 使用对象监视器实现

​	两个线程A、B竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可

**`private static volatile Object lock = new Object();`**

![image-20250409003933768](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409003933768.png?token=ARFL34FF4UJZVVRD2G4QGFTI562HW)

![image-20250409003948350](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409003948350.png)

![image-20250409003952621](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409003952621.png)

### 用两个线程，交替输出1A2B3C4D...26Z

- 跟两个线程交替打印奇数和偶数的对象监视器一样实现

![image-20250409004226701](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409004226701.png?token=ARFL34DL2GLEUCEDCORZGHTI562HY)

![image-20250409004230498](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409004230498.png?token=ARFL34EJLIKVJH2D3PBXFN3I562H4)

![image-20250409004235464](/Users/glexios/Library/Mobile Documents/com~apple~CloudDocs/Notes/场景题+项目排查问题+设计模式+手写代码+Streamis.assets/image-20250409004235464.png)

### 通过N个线程顺序循环打印从0至100

​	用等待唤醒机制，当一个线程执行完当前任务后再唤醒其他线程来执行任务，自己去休眠，避免在线程执行任务的时候其他线程处于忙等状态，浪费cpu资源。

![image-20250409012732358](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409012732358.png?token=ARFL34BDGFNULOVQ6JYHZK3I562H2)

![image-20250409012740339](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409012740339.png?token=ARFL34BXRQ6UP4SKYDOZ43LI562H4)

![image-20250409012745730](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250409012745730.png?token=ARFL34CUJD33THZZES4LGFTI562HY)
