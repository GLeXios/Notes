# cookie、session、token、jwt、单点登录

## 从状态说起

### **HTTP 无状态**

​	我们知道，HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。

​	但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。

那解决办法是什么呢？**标记**

> 在学校或公司，入学入职那一天起，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要刷这张卡

### **前端存储**

这就涉及到一发、一存、一带，发好办，登陆接口直接返回给前端，存储就需要前端想办法了。

前端的存储方式有很多。

- 最矬的，挂到全局变量上，但这是个「体验卡」，一次刷新页面就没了
- 高端点的，存到 cookie、localStorage 等里，这属于「会员卡」，无论怎么刷新，只要浏览器没清掉或者过期，就一直拿着这个状态。

前端存储这里不展开了。

有地方存了，请求的时候就可以拼到参数里带给接口了。

## 基石：cookie

> 可是前端好麻烦啊，又要自己存，又要想办法带出去，有没有不用操心的？

有，cookie。

- cookie 也是前端存储的一种，但相比于 localStorage 等其他方式，借助 HTTP 头、浏览器能力，cookie 可以做到前端无感知。**<font color = '#8D0101'>Cookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。</font>**


一般过程是这样的：

- 客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。

- 在提供标记的接口，通过 **HTTP 返回头的 Set-Cookie 字段**，客户端浏览器会把 Cookie 保存下来。
- 浏览器发起请求时，会自动把 cookie 通过 **HTTP 请求头的 Cookie 字段，带给接口**

### **配置：Domain / Path**

> 你不能拿清华的校园卡进北大。

cookie 是要限制**「空间范围」**的，通过 Domain（域）/ Path（路径）两级。

> Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 http://www.example.com 会设为 http://example.com，而且以后如果访问http://example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。
>
> Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。
> —— Cookie — JavaScript 标准参考教程（alpha）

### **配置：Secure / HttpOnly**

> 有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。

cookie 可以限制::「使用方式」::。

> Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。
> HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。
> —— Cookie — JavaScript 标准参考教程（alpha）

### **HTTP 头对 cookie 的读写**

回过头来，HTTP 是如何写入和传递 cookie 及其配置的呢？

HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：

```text
Set-Cookie: username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）

```text
Set-Cookie: username=jimu; domain=jimu.com
Set-Cookie: height=180; domain=me.jimu.com
Set-Cookie: weight=80; domain=me.jimu.com
```

HTTP 请求的 Cookie 头用于浏览器把符合当前「空间、时间、使用方式」配置的所有 cookie 一并发给服务端。因为由浏览器做了筛选判断，就不需要归还配置内容了，只要发送键值就可以。

```text
Cookie: username=jimu; height=180; weight=80
```

### **前端对 cookie 的读写**

前端可以自己创建 cookie，如果服务端创建的 cookie 没加`HttpOnly`，那恭喜你也可以修改他给的 cookie。

调用`document.cookie`可以创建、修改 cookie，和 HTTP 一样，一次`document.cookie`能且只能操作一个 cookie。

```text
document.cookie = 'username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly';
```

调用`document.cookie`也可以读到 cookie，也和 HTTP 一样，能读到所有的非`HttpOnly` cookie。

```text
console.log(document.cookie);
// username=jimu; height=180; weight=80
```

（就一个 cookie 属性，为什么读写行为不一样？get / set 了解下）

### **cookie 是维持 HTTP 请求状态的基石**

了解了 cookie 后，我们知道 cookie 是最便捷的维持 HTTP 请求状态的方式，大多数前端鉴权问题都是靠 cookie 解决的。当然也可以选用别的存储方式（后面也会多多少少提到）。

## 应用方案：服务端 session

现在回想下，你刷卡的时候发生了什么？

> 其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。

这种操作，在前后端鉴权系统中，叫 session。

​	**HTTP是无状态的，为了能够在HTTP协议上保持住状态，Session 是服务器端存储的用户会话数据，通常与一个特定用户（会话）关联。服务器通过一个唯一的 Session ID 标识每个用户的 Session。**

典型的 session 登陆/验证流程：

![image-20251018235648155](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235648155.png)

- 浏览器登录发送账号密码，服务端查用户库，校验用户
- 服务端把用户登录状态存为 Session，生成一个 sessionId
- 通过登录接口返回，把 sessionId set 到 cookie 上
- 此后浏览器再请求业务接口，sessionId 随 cookie 带上
- 服务端查 sessionId 校验 session
- 成功后正常做业务处理，返回结果

### Cookie 与 Session 的协作

1. **流程** ：
   - 用户首次登录时，服务器创建 Session 并生成唯一的 Session ID。
   - 服务器将 Session ID 通过 **Cookie** 发送给客户端（`Set-Cookie: sessionId=abc123`）。
   - 后续请求中，客户端自动携带 Cookie（含 Session ID），服务器根据 ID 查找对应的 Session 数据。
2. **依赖关系** ：
   - Session 依赖 Cookie 传递 Session ID（也可通过 URL 参数，但不推荐）。
   - 如果客户端禁用 Cookie，Session 会失效（需改用其他方式传递 ID）。

###  Java中的Session域

- Java通过HttpSession接口来实现Session技术；
- 每个客户端都有一个自己的Session会话；
- Session由服务器创建，保存在服务器中。
- session可以设置超时时间（以秒为单位），超过这个时间，session就会被销毁。

**Session域的创建**

session的创建和获取都使用同一个API：`request.getSession()`

- 第一次调用时，创建Session会话，
- 之后每次调用，获取前面创建的会话

通过`isNew()`方法判断是否新创建的会话：

- true：新创建的。
- false：获取之前创建的。

每个会话都有一个唯一ID，可以通过getId()方法获取。

```java
public class SessionServlet extends HttpServlet {
    protected void createSession(HttpServletRequest request, HttpServletResponse response) throws Exception{
        // 创建和获取Session
        HttpSession session = request.getSession();
        // 判断当前Session是否最新
        boolean isNew = session.isNew();
        // 获取SessionID
        String id = session.getId(); 
    }
}
```

### Session 的存储方式

显然，服务端只是给 cookie 一个 sessionId，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：

- Redis（推荐）：内存型数据库，redis中文官方网站。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。
- 内存：直接放到变量里。一旦服务重启就没了
- 数据库：普通数据库。性能不高。

### Session 的分布式问题

通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？

这个问题现在有几种解决方式。

- 一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。
- 二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。

但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。

## 对域名的解释

### 1. 域名分级

**（1）定义**

- **一级域名（顶级域名，TLD）**
  如 `.com`、`.org`、`.cn`，由 ICANN 管理，不可注册为个人使用。
- **二级域名（主域名）**
  用户可注册的部分，如 `example.com`。
- **三级域名（子域名）**
  在二级域名下创建，如 `www.example.com`、`api.example.com`。

**(2) 示例**

| 完整域名               | 级别     | 说明             |
| ---------------------- | -------- | ---------------- |
| `example.com`          | 二级域名 | 用户注册的主域名 |
| `www.example.com`      | 三级域名 | 常见的网站子域名 |
| `blog.api.example.com` | 四级域名 | 多级子域名       |

### 2.跨域问题（CORS）

**(1) 同源策略（Same-Origin Policy）**

​	出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

​	同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。==所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）==

- **定义**：协议、域名、端口完全一致才视为同源。
- 示例
  - `https://www.example.com` vs `http://www.example.com` → **跨域**（协议不同）。
  - `https://www.example.com` vs `https://api.example.com` → **跨域**（域名不同）。
  - `https://www.example.com:443` vs `https://www.example.com:8080` → **跨域**（端口不同）。

| 当前页面url               | 被请求页面url                   | 是否跨域 | 原因                           |
| ------------------------- | ------------------------------- | -------- | ------------------------------ |
| http://www.test.com/      | http://www.test.com/index.html  | 否       | 同源（协议、域名、端口号相同） |
| http://www.test.com/      | https://www.test.com/index.html | 跨域     | 协议不同（http/https）         |
| http://www.test.com/      | http://www.baidu.com/           | 跨域     | 主域名不同（test/baidu）       |
| http://www.test.com/      | http://blog.test.com/           | 跨域     | 子域名不同（www/blog）         |
| http://www.test.com:8080/ | http://www.test.com:7001/       | 跨域     | 端口号不同（8080/7001）        |

### 3.Nginx反向代理解决跨域

Nginx 实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。

使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

我们只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的 javascript可以跨域调用所有这些服务器上的url。

eg：

```nginx
server {
        listen       9000;
        server_name  localhost;
 
        #charset koi8-r;
 
        #access_log  logs/host.access.log  main;
 
        location / {
            root   html;
            index  index.html index.htm;
        }
        #自己前端的cli
		location /potato-cli-market/ {
			proxy_pass   http://localhost:8080/potato-cli-market/;
		}
        #自己后端的web
		location /potato-web-market/ {
			proxy_pass   http://localhost:8081/potato-web-market/;
		}
        #请求基金接口
		location /fund/ {
			proxy_pass    http://fundgz.1234567.com.cn/;
		}
}
```

监听的地址为localhost和端口为9000;

请求地址如下：localhost:9000/potato-cli-market/mallTypeManage会直接转发到localhost:8080/potato-cli-market/mallTypeManage

同样如果请求：localhost:9000/potato-web-market/hello会直接转发到localhost:8081/potato-web-market/hello上

同样如果请求基金的接口：localhost:9000/fund/js/001186.js?rt=1463558676006会直接转发到 http://fundgz.1234567.com.cn/js/001186.js?rt=1463558676006

Eg2:

对于前端资源文件：

请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 `/usr/local/nginx/html/jinlu-admin/` 目录（我们需要将静态资源文件上传到`/usr/local/nginx/html/jinlu-admin/` 目录下）下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。

```
location /jinlu-admin/ {
   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘
   expires 30d; #缓存30天
}
```



后端

```nginx
server {
		listen       9000;
    server_name  javaboy.org;

    location /jinlu/ {
      proxy_pass http://zqq.com;
      tcp_nodelay     on;
      proxy_set_header Host            $host;
      proxy_set_header X-Real-IP       $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
」
```

这样配置完成后，假设目前的域名是 javaboy.org，那么用户通过 `http://www.javaboy.org/jinlu/**` 格式的地址就可以访问到我服务端的接口



## 应用方案：token

session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？

> 我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。

Token的意思是“令牌”，是一种网络认证方式，是服务端生成的一串字符串，用于识别客户端的身份，不能用来存储客户端信息，可作为客户端进行请求的一个标识。

当用户第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

### Token的组成

- uid：用户唯一的身份标识
- time：当前时间的时间戳
- sign：签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接

- 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接


### token存放位置

- token在==客户端==一般存放于localStorage，cookie，或sessionStorage（不建议）中。（**==放在localstaorage也就是浏览器缓存中的话不会有csrf攻击困扰==**）
- 在==服务器==一般存于数据库中。

### 基于token机制的身份认证

使用token机制的[身份验证](https://cloud.tencent.com/product/idam?from_column=20065&from=20065)方法，在服务器端不需要存储用户的登录记录。大概的流程：

1. 客户端使用用户名和密码请求登录。
2. 服务端收到请求，验证用户名和密码。
3. 验证成功后，服务端会生成一个token，然后把这个token发送给客户端。
4. **客户端收到token后把它存储起来，可以放在==cookie==或者Storage里**。
5. 客户端每次向服务端发送请求的时候都需要带上服务端发给的token。
6. 服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。(**如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。)**

![image-20251018235715838](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235715838.png)

### token 的编码:base64和防篡改

编码的方式丰俭由人。

**base64**

比如 node 端的 cookie-session - npm 库

> 不要纠结名字，其实是个 token 库，但保持了和 express-session - npm 高度一致的用法，把要存的数据挂在 session 上

默认配置下，当我给他一个 userid，他会存成这样：

![image-20251018235751558](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235751558.png)

这里的 `eyJ1c2VyaWQiOiJhIn0=`，就是 `{"userid":"abb”}` 的 base64 而已。

**防篡改**

> 那问题来了，如果用户 cdd 拿`{"userid":"abb”}`转了个 base64，再手动修改了自己的 token 为 `eyJ1c2VyaWQiOiJhIn0=`，是不是就能直接访问到 abb 的数据了？

是的。所以看情况，如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。

解决方案就是给 **token 加签名**，来识别 token 是否被篡改过。例如在 cookie-session - npm 库中，增加两项配置：

```text
secret: 'iAmSecret',
signed: true,
```

这样会多种一个 **.sig cookie**，里面的值就是 `{"userid":"abb”}` 和 `iAmSecret`通过加密算法计算出来的，常见的比如HMACSHA256 类 (System.Security.Cryptography) | Microsoft Docs。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/v2-d1856a525e546e7ff2ac9641c756569e_1440w.jpg)

好了，现在 cdd 虽然能伪造出`eyJ1c2VyaWQiOiJhIn0=`，但伪造不出 sig 的内容，因为他不知道 secret。

### 解决Token失效的问题：refresh token

​	业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？

- 一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。

- 另外一种办法是，再来一个 token，一**个专门生成 access token 的 token，我们称为 ==refresh token==**。

  - **access token 用来访问业务接口**，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活

  - **refresh token 用来获取 access token**，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

有了 refresh token 后，几种情况的请求流程变成这样：（如果 refresh token 也过期了，就只能重新登录了。）

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/v2-55c42752755097d8ec463876be9939b6_1440w.jpg" alt="img" style="zoom:67%;" />

# 项目的异常处理

**==全部异常继承自LinkisException==**

## LinkisException

### 1. 类定义与继承关系

```java
public abstract class LinkisException extends Exception {
    // ...
}
```

- **定位**：作为 Apache Linkis 项目的**自定义异常基类**，所有 Linkis 相关异常应继承此类。
- **抽象类**：要求子类必须实现 `getLevel()` 方法，明确异常级别（如 ERROR、WARN）。
- **继承自** `Exception`：属于受检异常（Checked Exception），强制调用方处理。

### 2. 核心方法解析

**(1) 构造方法**

```java
// 简化构造：自动填充静态全局信息
public LinkisException(int errCode, String desc) {
    this(errCode, desc, hostname, hostPort, applicationName);
}

// 完整构造：允许自定义异常上下文
public LinkisException(int errCode, String desc, String ip, int port, String serviceKind) {
    super("errCode: " + errCode + " ,desc: " + desc + " ,ip: " + ip + " ,port: " + port + " ,serviceKind: " + serviceKind);
    // 初始化成员变量...
}
```

- **作用**：封装异常上下文信息，自动生成详细错误消息。
- **设计意图**：统一异常信息格式，便于日志收集与分析。

**(2) 抽象方法**

```java
abstract ExceptionLevel getLevel();
```

- **强制子类实现**：定义异常级别（如 `ExceptionLevel.ERROR`、`ExceptionLevel.WARN`）。

- 设计意图：驱动异常分类处理，例如：

  - `ERROR`：触发告警通知。
- `WARN`：记录日志但不中断流程

**(3) 静态配置方法**

```java
public static void setApplicationName(String applicationName) { /*...*/ }
public static void setHostname(String hostname) { /*...*/ }
public static void setHostPort(int hostPort) { /*...*/ }
```

- **用途**：全局设置应用名称、主机名、端口（通常在应用启动时配置）。

- 示例

  ```java
  LinkisException.setApplicationName("Linkis-DataService");
  LinkisException.setHostname("data-node-01");
  LinkisException.setHostPort(9090);
  ```

### 3. 使用场景示例

**(1) 定义子类异常**

```Java
package org.apache.linkis.common.exception;

public class ErrorException extends LinkisException {
    private ExceptionLevel level;

    public ErrorException(int errCode, String desc) {
        super(errCode, desc);
        this.level = ExceptionLevel.ERROR;
    }

    public ErrorException(int errCode, String desc, String ip, int port, String serviceKind) {
        super(errCode, desc, ip, port, serviceKind);
        this.level = ExceptionLevel.ERROR;
    }

    public ExceptionLevel getLevel() {
        return this.level;
    }
}
```

**(2) 抛出异常**

```java
public void startEngine() throws ErrorException {
    if (engine == null) {
        throw new EngineException(30001"Engine initialization failed");
    }
    // ...
}
```

**(3) 处理异常**

```java
try {
    engineService.startEngine();
} catch (ErrorException e) {
    log.error("Engine error: {}", e.toMap());  // 结构化日志
    if (e.getLevel() == ExceptionLevel.ERROR) {
        alertManager.notify(e);  // 触发告警
    }
}
```



# 数据结构

## 递归

递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，递归代码主要包含三个要素。

1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 1+2+⋯+n 的计算：

```java
/* 递归 */
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/recursion_sum.png" alt="求和函数的递归过程" style="zoom:50%;" />

### 调用栈

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。

在触发终止条件前，同时存在 n 个未返回的递归函数，**递归深度为 n** 。

![image-20251018235818257](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235818257.png)

​	那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，**这种工作机制与栈的“先入后出”原则异曲同工**。

事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。

1. **递**：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。
2. **归**：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。

## 排序的稳定性

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps124.jpg) 

## 排序复杂度

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps125.jpg" alt="img" style="zoom:35%;" /> 

## 抽象数据结构复杂度

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps126.jpg" alt="img" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250327134414430.png" alt="image-20250327134414430" style="zoom:33%;" />

## 数组

### 简介

​	数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/array_definition.png" alt="数组定义与存储方式" style="zoom:40%;" />

### 数组常用操作

#### 初始化数组

​	我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 

```java
/* 初始化数组 */
int[] arr = new int[5]; // { 0, 0, 0, 0, 0 }
int[] nums = { 1, 3, 2, 5, 4 };
```

#### 插入元素

​	数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如图 4-3 所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/array_insert_element.png" alt="数组插入元素示例" style="zoom:45%;" />

​	值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。

```java
/* 在数组的索引 index 处插入元素 num */
void insert(int[] nums, int num, int index) {
    // 把索引 index 以及之后的所有元素向后移动一位
    for (int i = nums.length - 1; i > index; i--) {
        nums[i] = nums[i - 1];
    }
    // 将 num 赋给 index 处的元素
    nums[index] = num;
}
```

#### 删除元素

同理，如图所示，若想删除索引 i 处的元素，则需要把索引 i 之后的元素都向前移动一位。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/array_remove_element.png" alt="数组删除元素示例" style="zoom:45%;" />

```java
/* 删除索引 index 处的元素 */
void remove(int[] nums, int index) {
    // 把索引 index 之后的所有元素向前移动一位
    for (int i = index; i < nums.length - 1; i++) {
        nums[i] = nums[i + 1];
    }
}
```

#### 遍历数组

在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：

```java
/* 遍历数组 */
void traverse(int[] nums) {
    int count = 0;
    // 通过索引遍历数组
    for (int i = 0; i < nums.length; i++) {
        count += nums[i];
    }
    // 直接遍历数组元素
    for (int num : nums) {
        count += num;
    }
}
```

####  扩容数组

​	在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，**数组的长度是不可变的**。

​	如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。

```java
/* 扩展数组长度 */
int[] extend(int[] nums, int enlarge) {
    // 初始化一个扩展长度后的数组
    int[] res = new int[nums.length + enlarge];
    // 将原数组中的所有元素复制到新数组
    for (int i = 0; i < nums.length; i++) {
        res[i] = nums[i];
    }
    // 返回扩展后的新数组
    return res;
}
```

### 数组的优点与局限性

​	数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。

- **空间效率高**：数组为数据分配了连续的内存块，无须额外的结构开销。
- **支持随机访问**：数组允许在 O(1) 时间内访问任何元素。
- **缓存局部性**：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。

连续空间存储是一把双刃剑，其存在以下局限性。

- **插入与删除效率低**：当数组中元素较多时，插入与删除操作需要移动大量的元素。
- **长度不可变**：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
- **空间浪费**：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。

#### 数组典型应用

数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。

- **随机访问**：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。
- **排序和搜索**：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。
- **查找表**：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。
- **机器学习**：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。
- **数据结构实现**：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。

## 链表

### 简介

​	**链表（linked list）是一种线性数据结构**，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/linkedlist_definition.png" alt="链表定义与存储方式" style="zoom:40%;" />

链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。

- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。
- 尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 `null`、`nullptr` 和 `None` 。
- 在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。

### 链表常用操作

#### 初始化链表

​	建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 `next` 依次访问所有节点。

- 数组整体是一个变量，比如数组 `nums` 包含元素 `nums[0]` 和 `nums[1]` 等，而链表是由多个独立的节点对象组成的。**我们通常将头节点当作链表的代称**，比如以上代码中的链表可记作链表 `n0` 。

```java
/* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */
// 初始化各个节点
ListNode n0 = new ListNode(1);
ListNode n1 = new ListNode(3);
ListNode n2 = new ListNode(2);
ListNode n3 = new ListNode(5);
ListNode n4 = new ListNode(4);
// 构建节点之间的引用
n0.next = n1;
n1.next = n2;
n2.next = n3;
n3.next = n4;
```

#### 插入节点

​	在链表中插入节点非常容易。如图所示，假设我们想在相邻的两个节点 `n0` 和 `n1` 之间插入一个新节点 `P` ，**则只需改变两个节点引用（指针）即可**，时间复杂度为 O(1) 。

相比之下，在数组中插入元素的时间复杂度为 O(n) ，在大数据量下的效率较低。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/linkedlist_insert_node.png" alt="链表插入节点示例" style="zoom:40%;" />

```java
/* 在链表的节点 n0 之后插入节点 P */
void insert(ListNode n0, ListNode P) {
    ListNode n1 = n0.next;
    P.next = n1;
    n0.next = P;
}
```

#### 删除节点

如图所示，在链表中删除节点也非常方便，**只需改变一个节点的引用（指针）即可**。

​	请注意，尽管在删除操作完成后节点 `P` 仍然指向 `n1` ，但实际上遍历此链表已经无法访问到 `P` ，这意味着 `P` 已经不再属于该链表了。

![image-20251018235849679](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235849679.png)

```java
/* 删除链表的节点 n0 之后的首个节点 */
void remove(ListNode n0) {
    if (n0.next == null)
        return;
    // n0 -> P -> n1
    ListNode P = n0.next;
    ListNode n1 = P.next;
    n0.next = n1;
}
```

#### 查找节点

遍历链表，查找其中值为 `target` 的节点，输出该节点在链表中的索引。此过程也属于线性查找。

```java
/* 在链表中查找值为 target 的首个节点 */
int find(ListNode head, int target) {
    int index = 0;
    while (head != null) {
        if (head.val == target)
            return index;
        head = head.next;
        index++;
    }
    return -1;
}
```

### 数组 vs. 链表

​	下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。

|          | 数组                           | 链表           |
| :------- | :----------------------------- | :------------- |
| 存储方式 | 连续内存空间                   | 分散内存空间   |
| 容量扩展 | 长度不可变                     | 可灵活扩展     |
| 内存效率 | 元素占用内存少、但可能浪费空间 | 元素占用内存多 |
| 访问元素 | O(1)                           | O(n)           |
| 添加元素 | O(n)                           | O(1)           |
| 删除元素 | O(n)                           | O(1)           |

###  常见链表类型

常见的链表类型包括三种。

- **单向链表**：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 `None` 。
- **环形链表**：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。
- **双向链表**：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。

```java
/* 双向链表节点类 */
class ListNode {
    int val;        // 节点值
    ListNode next;  // 指向后继节点的引用
    ListNode prev;  // 指向前驱节点的引用
    ListNode(int x) { val = x; }  // 构造函数
}
```

### 链表典型应用

**单向链表**通常用于实现栈、队列、哈希表和图等数据结构。

- **栈与队列**：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。
- **哈希表**：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。
- **图**：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。

**双向链表**常用于需要快速查找前一个和后一个元素的场景。

- **高级数据结构**：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。
- **浏览器历史**：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。
- **LRU 算法**：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。

**环形链表**常用于需要周期性操作的场景，比如操作系统的资源调度。

- **时间片轮转调度算法**：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。
- **数据缓冲区**：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。

## 列表

​	列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。**列表可以基于链表或数组实现**。

- 链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。
- 数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。

### 列表常用操作

#### 初始化列表

我们通常使用“无初始值”和“有初始值”这两种初始化方法：

```java
/* 初始化列表 */
// 无初始值
List<Integer> nums1 = new ArrayList<>();
// 有初始值（注意数组的元素类型需为 int[] 的包装类 Integer[]）
Integer[] numbers = new Integer[] { 1, 3, 2, 5, 4 };
List<Integer> nums = new ArrayList<>(Arrays.asList(numbers));
```

#### 插入与删除元素

​	相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。

```java
/* 清空列表 */
nums.clear();

/* 在尾部添加元素 */
nums.add(1);
nums.add(3);
nums.add(2);
nums.add(5);
nums.add(4);

/* 在中间插入元素 */
nums.add(3, 6);  // 在索引 3 处插入数字 6

/* 删除元素 */
nums.remove(3);  // 删除索引 3 处的元素
```

#### 遍历列表

与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。

```java
/* 通过索引遍历列表 */
int count = 0;
for (int i = 0; i < nums.size(); i++) {
    count += nums.get(i);
}

/* 直接遍历列表元素 */
for (int num : nums) {
    count += num;
}
```

#### 拼接列表

给定一个新列表 `nums1` ，我们可以将其拼接到原列表的尾部。

```java
/* 拼接两个列表 */
List<Integer> nums1 = new ArrayList<>(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));
nums.addAll(nums1);  // 将列表 nums1 拼接到 nums 之后
```

#### 排序列表

完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法

```java
/* 排序列表 */
Collections.sort(nums);  // 排序后，列表元素从小到大排列
```

### 列表实现

为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。

- **初始容量**：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。
- **数量记录**：声明一个变量 `size` ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。
- **扩容机制**：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。

```java
/* 列表类 */
class MyList {
    private int[] arr; // 数组（存储列表元素）
    private int capacity = 10; // 列表容量
    private int size = 0; // 列表长度（当前元素数量）
    private int extendRatio = 2; // 每次列表扩容的倍数

    /* 构造方法 */
    public MyList() {
        arr = new int[capacity];
    }

    /* 获取列表长度（当前元素数量） */
    public int size() {
        return size;
    }

    /* 获取列表容量 */
    public int capacity() {
        return capacity;
    }

    /* 访问元素 */
    public int get(int index) {
        // 索引如果越界，则抛出异常，下同
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("索引越界");
        return arr[index];
    }

    /* 更新元素 */
    public void set(int index, int num) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("索引越界");
        arr[index] = num;
    }

    /* 在尾部添加元素 */
    public void add(int num) {
        // 元素数量超出容量时，触发扩容机制
        if (size == capacity())
            extendCapacity();
        arr[size] = num;
        // 更新元素数量
        size++;
    }

    /* 在中间插入元素 */
    public void insert(int index, int num) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("索引越界");
        // 元素数量超出容量时，触发扩容机制
        if (size == capacity())
            extendCapacity();
        // 将索引 index 以及之后的元素都向后移动一位
        for (int j = size - 1; j >= index; j--) {
            arr[j + 1] = arr[j];
        }
        arr[index] = num;
        // 更新元素数量
        size++;
    }

    /* 删除元素 */
    public int remove(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("索引越界");
        int num = arr[index];
        // 将将索引 index 之后的元素都向前移动一位
        for (int j = index; j < size - 1; j++) {
            arr[j] = arr[j + 1];
        }
        // 更新元素数量
        size--;
        // 返回被删除的元素
        return num;
    }

    /* 列表扩容 */
    public void extendCapacity() {
        // 新建一个长度为原数组 extendRatio 倍的新数组，并将原数组复制到新数组
        arr = Arrays.copyOf(arr, capacity() * extendRatio);
        // 更新列表容量
        capacity = arr.length;
    }

    /* 将列表转换为数组 */
    public int[] toArray() {
        int size = size();
        // 仅转换有效长度范围内的列表元素
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = get(i);
        }
        return arr;
    }
}
```

## 栈

栈（stack）是一种遵循**先入后出**逻辑的线性数据结构。

​	我们可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。我们将盘子替换为各种类型的元素（如整数、字符、对象等），就得到了栈这种数据结构。

​	如图所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/stack_operations.png" alt="栈的先入后出规则" style="zoom:40%;" />

### 栈的常用操作

​	栈的常用操作如表 5-1 所示，具体的方法名需要根据所使用的编程语言来确定。在此，我们以常见的 `push()`、`pop()`、`peek()` 命名为例。

表 5-1  栈的操作效率

| 方法     | 描述                   | 时间复杂度 |
| :------- | :--------------------- | :--------- |
| `push()` | 元素入栈（添加至栈顶） | O(1)       |
| `pop()`  | 栈顶元素出栈           | O(1)       |
| `peek()` | 访问栈顶元素           | O(1)       |

```java
/* 初始化栈 */
Stack<Integer> stack = new Stack<>();

/* 元素入栈 */
stack.push(1);
stack.push(3);
stack.push(2);
stack.push(5);
stack.push(4);

/* 访问栈顶元素 */
int peek = stack.peek();

/* 元素出栈 */
int pop = stack.pop();

/* 获取栈的长度 */
int size = stack.size();

/* 判断是否为空 */
boolean isEmpty = stack.isEmpty();
```

### 栈的典型应用

- **浏览器中的后退与前进、软件中的撤销与反撤销**。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。
- **程序内存管理**。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。

##  队列

​	队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。

​	如图所示，我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。

![image-20251018235914662](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018235914662.png)

### 队列常用操作

队列的常见操作如表所示。需要注意的是，不同编程语言的方法名称可能会有所不同。我们在此采用与栈相同的方法命名

| 方法名   | 描述                         | 时间复杂度 |
| :------- | :--------------------------- | :--------- |
| `push()` | 元素入队，即将元素添加至队尾 | O(1)       |
| `pop()`  | 队首元素出队                 | O(1)       |
| `peek()` | 访问队首元素                 | O(1)       |

```java
/* 初始化队列 */
Queue<Integer> queue = new LinkedList<>();

/* 元素入队 */
queue.offer(1);
queue.offer(3);
queue.offer(2);
queue.offer(5);
queue.offer(4);

/* 访问队首元素 */
int peek = queue.peek();

/* 元素出队 */
int pop = queue.poll();

/* 获取队列的长度 */
int size = queue.size();

/* 判断队列是否为空 */
boolean isEmpty = queue.isEmpty();
```

### 队列典型应用

- **淘宝订单**。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。
- **各类待办事项**。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序

## 哈希表

​	哈希表（hash table），又称散列表，它通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 `key` ，则可以在 O(1) 时间内获取对应的值 `value` 。

- ==Java 采用链式地址解决哈希冲突==。自 JDK 1.8 以来，当 `HashMap` 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。

### HashSet与HashMap常用方法和遍历方法

**HashSet 常用方法**：

- `add(E e)`: 添加元素，成功返回 `true`，重复元素返回 `false`。
- `remove(Object o)`: 删除指定对象，存在则返回 `true`，否则 `false`。
- `contains(Object o)`: 检查是否包含指定对象。
- `size()`: 返回集合大小。
- `isEmpty()`: 判断是否为空。
- `clear()`: 清空集合。

**HashSet 遍历方法**：

**增强 for 循环**：

```java
HashSet<String> set = new HashSet<>();
set.add("A");
set.add("B");
for (String item : set) {
    System.out.println(item);
}
```

**HashMap 常用方法**：

- `put(K key, V value)`: 插入键值对，返回旧值（无则返回 `null`）。
- `get(Object key)`: 通过键获取值，不存在返回 `null`。
- `remove(Object key)`: 删除键对应的键值对，返回被删除的值。
- `containsKey(Object key)`: 检查是否存在键。
- `containsValue(Object value)`: 检查是否存在值。
- `size()`: 返回键值对数量。
- `clear()`: 清空所有映射。
- `keySet()`: 返回所有键的集合（`Set<K>`）。
- `values()`: 返回所有值的集合（`Collection<V>`）。
- `entrySet()`: 返回所有键值对的集合（Set<Map.Entry<K, V>>）。

**HashMap 遍历方法**：

1. **遍历键（Key）**：

   ```java
   HashMap<Integer, String> map = new HashMap<>();
   map.put(1, "A");
   map.put(2, "B");
   
   for (Integer key : map.keySet()) {
       System.out.println("Key: " + key);
   
   ```

2. **遍历值（Value）**：

   ```java
   for (String value : map.values()) {
       System.out.println("Value: " + value);
   }
   ```

3. **遍历键值对（Entry）**：**增强 for 循环 + entrySet()**：

   ```java
   for (Map.Entry<Integer, String> entry : map.entrySet()) {
       System.out.println("Key=" + entry.getKey() + ", Value=" + entry.getValue());
   }
   ```

### HashMap和HashSet对比

![image-20250309140528344](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250309140528344-4133873.png)

### 哈希算法

​	当哈希表容量 `capacity` 固定时，**哈希算法 `hash()` 决定了输出值**，进而决定了键值对在哈希表中的分布情况。这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法 `hash()` 的设计上。

### 哈希算法的特点与应用

**【哈希算法的应用】**

哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。

- **密码存储**：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。
- **数据完整性检查**：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。

**【哈希算法的特点】**

为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。

- **确定性**：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。
- **效率高**：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。
- **均匀分布**：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。

## 常见哈希算法

​	通常会用一些标准哈希算法，例如 **MD5、SHA-1、SHA-2 和 SHA-3** 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。

## 树

​	二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。

```java
/* 二叉树节点类 */
class TreeNode {
    int val;         // 节点值
    TreeNode left;   // 左子节点引用
    TreeNode right;  // 右子节点引用
    TreeNode(int x) { val = x; }
}
```

​	每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，**我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）**。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/binary_tree_definition.png" alt="父节点、子节点、子树" style="zoom:33%;" />

### 二叉树常见术语

二叉树的常用术语如图 7-2 所示。

- 根节点（root node）：位于二叉树顶层的节点，没有父节点。
- 叶节点（leaf node）：没有子节点的节点，其两个指针均指向 `None` 。
- 边（edge）：连接两个节点的线段，即节点引用（指针）。
- 节点所在的层（level）：从顶至底递增，根节点所在层为 1 。
- 节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。
- 二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。
- 节点的深度（depth）：从根节点到该节点所经过的边的数量。
- 节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/binary_tree_terminology.png" alt="二叉树的常用术语" style="zoom:50%;" />

### 二叉树遍历

​	树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。

二叉树常见的遍历方式包括**层序遍历、前序遍历、中序遍历和后序遍历**等。

#### 层序遍历

​	层序遍历（level-order traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。

​	**层序遍历本质上属于广度优先遍历（breadth-first traversal）**，也称**广度优先搜索（breadth-first search, BFS）**，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/binary_tree_bfs.png" alt="二叉树的层序遍历" style="zoom:40%;" />

广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的

```java
/* 层序遍历 */
List<Integer> levelOrder(TreeNode root) {
    // 初始化队列，加入根节点
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    // 初始化一个列表，用于保存遍历序列
    List<Integer> list = new ArrayList<>();
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // 队列出队
        list.add(node.val);           // 保存节点值
        if (node.left != null)
            queue.offer(node.left);   // 左子节点入队
        if (node.right != null)
            queue.offer(node.right);  // 右子节点入队
    }
    return list;
}
```

#### 前序、中序、后序遍历

​	前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/binary_tree_dfs.png" alt="二叉搜索树的前序、中序、后序遍历" style="zoom:47%;" />

```java
/* 前序遍历 */
void preOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：根节点 -> 左子树 -> 右子树
    list.add(root.val);
    preOrder(root.left);
    preOrder(root.right);
}

/* 中序遍历 */
void inOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：左子树 -> 根节点 -> 右子树
    inOrder(root.left);
    list.add(root.val);
    inOrder(root.right);
}

/* 后序遍历 */
void postOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：左子树 -> 右子树 -> 根节点
    postOrder(root.left);
    postOrder(root.right);
    list.add(root.val);
}
```

# 