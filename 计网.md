# 计算机网络

## 基础篇

### OSI与TCP/IP各层的结构与功能，都有哪些协议？

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps61-2889381.jpg) 

![image-20250325155500066](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325155500066.png)

### TCP/IP网络模型

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322223108114-2889381.png" alt="image-20250322223108114" style="zoom:80%;" />

![image-20250322224605526](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322224605526.png)

#### 应用层

​	最上层的，也是我们能直接接触到的就是应用层（Application Layer），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。所以，**应用层只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。<font color = '#8D0101'>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</font>**。

![image-20250322223146365](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322223146365-2889381.png)

**【常见的应用层协议】**

![image-20250322223214740](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322223214740-2889381.png)

#### 传输层

应用层的数据包会传给传输层，**传输层（Transport Layer）是为应用层提供网络支持的**。

在传输层会有两个传输协议，分别是**TCP和UDP**

- **TCP的全称叫传输控制协议（Transmission Control Protocol）**，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如**流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方**。

- **UDP相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方**，但它实时性相对更好，传输效率也高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠UDP传输协议，也不是一件简单的事情

​	应用层需要传输的数据可能会非常大，如果直接传输就不好控制，因此**当传输层的数据包大小超过MSS（TCP最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包**。在TCP协议中，我们把每个分块称为一个TCP段（TCP Segment）。

![image-20250322223539211](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322223539211-2889381.png)

​	当设备作为接收方时，传输层则要负责把数据包传给应用，但是**一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<font color = '#8D0101'>端口</font>**。

- **<font color = '#8D0101'>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用</font>**。
- 比如80端口通常是Web服务器用的，22端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号

#### 网络层

**【ip协议】**

​	我们不希望**传输层协议**处理太多的事情，只需要服务好应用即可，让其**作为应用间数据传输的媒介，帮助实现应用到应用的通信**，而**实际的传输功能就交给下一层，也就是网络层（Internet Layer）**。

- 即：**<font color = '#8D0101'>运输层为应用进程之间提供端到端的逻辑通信，网络层是为主机之间提供逻辑通信。故网络层不提供服务质量的承诺</font>。**

​	网络层最常使用的是**IP协议**（Internet Protocol），IP协议会**将传输层的报文作为数据部分，再加上IP包头组装成IP报文**，如果**IP报文大小超过MTU（Maximum Transfer Unit，最大传送单元，以太网中一般为1500字节）就会再次进行分片**（在实际中尽量避免IP报文触发IP切片，数据最好在TCP中分段成满足要求的长度），得到一个即将发送到网络的IP报文。

![image-20250322224121713](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322224121713.png)

**【寻址】**

​	网络层负责将数据从一个设备传输到另一个设备，因此，网络层需要有区分设备的编号，确保设备之间能找到对方，一般**用IP地址给设备进行编号**，对于IPv4协议，IP地址共32位，分成了四段（比如，192.168.100.1），每段是8位。

- **网络号，负责标识该IP地址是属于哪个「子网」的；**
- **主机号，负责标识同一「子网」下的不同主机；**

**【路由】**

​	除了**寻址能力**，IP协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径

- **<font color = '#8D0101'>IP协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</font>**。

![image-20250322224551457](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322224551457.png)

#### 网络接口层

​	生成了IP头部之后，接下来要交给网络接口层（Link Layer）在**IP头部的前面加上MAC(Media Access Control，介质访问地址头部)，并封装成数据帧（Data frame）发送到网络上**

​	以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的，所以，在以太网进行通讯要用到MAC地址。

- **MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息**，我们可以通过**<font color = '#8D0101'>ARP协议</font>(地址解析协议)获取对方的MAC地址**。

## HTTP篇(应用层)

### HTTP基本概念

#### HTTP**协议简介**

​	**HTTP协议是超文本传输协议(HyperText Transfer Protocol)**，是用于从万维网服务器传输超文本到本地浏览器的传送协议。它基于TCP/IP通信协议来传递数据（HTML文件，图片文件，查询结果等）。HTTP是一个数据应用层的面向对象的协议，由于其简介、快速的方式，适用于分布式超媒体信息系统，目前有http1.0,1.1以及2.0。它工作于客户端-服务端架构上，**浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送请求，web服务器根据接收到的请求后，向客户端发送响应信息**。

**主要特点**

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322230019379.png" alt="image-20250322230019379" style="zoom:80%;" />

#### ==HTTP常见的状态码==

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps62.jpg) 

**<u>1）1xx和2xx</u>**

**1xx类状态码**属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

**2xx类状态码**表示服务器**成功处理了客户端的请求**，也是我们最愿意看到的状态。

- **「200 OK」**是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据。
- **「204 No Content」**也是常见的成功状态码，与200 OK基本相同，但响应头没有body数据。
- **「206 Partial Content」**是应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

**<u>2）3xx</u>**

​	**3xx类状态码**表示客户端请求的**资源发生了变动**，需要客户端用新的URL重新发送请求获取资源，也就是**重定向**

- **「301 Moved Permanently」**表示永久重定向，说明请求的资源已经不存在了，需改用新的URL再次访问。
- **「302 Found」**表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问。
  - 301和302都会在响应头里使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL。
- **「304 Not Modified」**不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

**<u>3）4xx</u>**

4xx类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- **「400 Bad Request」**表示客户端请求的报文有错误，但只是个笼统的错误。
- **「403 Forbidden」**表示服务器禁止访问资源，并不是客户端的请求出错。
- **「404 Not Found」**表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

**<u>4）5xx</u>**

5xx类状态码表示**客户端请求报文正确**，但是服务器处理时内部发生了错误，属于服务器端的错误码。

- **「500 Internal Server Error」**与400类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- **「501 Not Implemented」**表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- **「502 Bad Gateway」**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- **「503 Service Unavailable」**表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#### HTTP请求有哪些

![image-20250322230417370](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322230417370.png)

##### GET和POST区别

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps65.jpg) 

- **Get**方法的含义是请求从服务器获取指定的资源，这个资源可以是静态的文本、页面、视频等。**GET请求的参数位置一般是写在URL中，是明文显示的**，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符，而且浏览器会对URL的长度有限制。
- **POST**则是相反操作，**它根据请求负荷（报文body）对URL指定的资源进行处理(比如提交数据、修改数据)，请求数据就放在报文的请求体body里**。

#####  GET和POST方法都是安全和幂等的吗

<u>**1）安全和幂等的概念**</u>

- **在HTTP协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。**
- **所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。**

<u>**2）从RFC规范定义的语义**</u>

- **GET方法就是安全且幂等的**，因为**它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的**。所以，可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中GET请求可以保存为书签。
- **POST因为是「新增或提交数据」的操作**，**会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的**。所以，浏览器一般不会缓存POST请求，也不能把POST请求保存为书签。

<u>**3）关于安全**</u>

- 因为HTTP传输的内容都是明文的，虽然在浏览器地址栏看不到POST提交的body数据，但是只要抓个包就都能看到了。
- 所以，要避免传输过程中数据被窃取，就要使用**HTTPS协议**，这样所有HTTP的数据都会被加密传输

##### PUT和POST区别

![image-20250322230705357](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322230705357.png)

#### HTTP(1.1)的优缺点（无状态、明文传输等）

HTTP协议里有优缺点一体的双刃剑，分别是**「无状态、明文传输」**，同时还有一大**缺点「不安全」**。

**<u>1）无状态双刃剑</u>**

- **无状态的好处**，因为服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能**减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务**。
- **无状态的坏处**，既然服务器没有记忆能力，它在完成**有关联性的操作时会非常麻烦**。

对于无状态的问题，解法方案有很多种，其中比较简单的方式：

**Cookie技术：Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态**

- 在客户端第一次请求后，服务器会下发一个装有客户信息的cookie，后续客户端请求服务器的时候，带上cookie，服务器就能知道客户端是谁了.

![image-20250322234352192](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322234352192.png)

![image-20250322234401012](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250322234401012.png)

**<u>2）明文传输双刃剑</u>**

- 明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的F12控制台或Wireshark抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。
- 但是这正是这样，HTTP的所有信息都暴露出来了。在传输的过程中，信息的内容都毫无隐私可言，很容易就能被窃取。

**<u>3）不安全</u>**

- 通信使用明文（不加密），内容可能会被窃听。比如账号信息容易泄漏，那你号没了
- 不验证通信方的身份，因此有可能遭遇伪装。比如访问假的淘宝、拼多多，那你钱没了。
- 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。

HTTP的安全问题，可以用HTTPS的方式解决，也就是通过引入SSL/TLS层，使得在安全上达到了极致

### HTTP缓存技术

#### HTTP缓存有哪些实现方式

​	对于一些具有重复性的HTTP请求，比如每次请求得到的数据都一样的，我们可以**把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了**，这样的话HTTP/1.1的性能肯定肉眼可见的提升。

HTTP缓存有两种实现方式，分别是**强制缓存和协商缓存**。

#### 强制缓存(cache control和Expires)

​	强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，由浏览器决定是否使用缓存。

​	**强制缓存是利用下面这两个HTTP响应头部（Response Header)字段实现的**，它们都用来表示资源在客户端缓存的有效期。

- **<font color = '#8D0101'>Cache-Control：是一个相对时间;</font>**
- <font color = '#8D0101'>**Expires：是一个绝对时间;**</font>
- 如果HTTP响应头部同时有Cache-Control和Expires字段的话，**Cache-Control的优先级高于Expires**。

**Cache-control实现强制缓存流程如下：**

- **当浏览器第一次请求访问服务器资源时**，服务器会在返回这个资源的同时，在Response头部加上Cache-Control，Cache-Control中设置了过期时间大小；
- **浏览器再次请求访问服务器中的该资源时**，**会先通过请求资源的时间与Cache-Control中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会**再次更新Response头部的Cache-Control**。

#### 协商缓存

**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。**

​	当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

​	注意，**<font color = '#8D0101'>协商缓存这两个字段都需要配合强制缓存中Cache-control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</font>**

**【协商缓存可以基于两种头部来实现】**

​	**第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的**，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

​	如果HTTP响应头部同时有Etag和Last-Modified字段的时候，**Etag的优先级更高**，也就是先会判断Etag是否变化了，如果Etag没有变化，然后再看Last-Modified。

**1）请求头部中的If-Modified-since字段与响应头部中的Last-Modified字段实现**

- **响应头部**中的**Last-Modified**:标示这个响应资源的最后修改时间;
- **请求头部**中的**If-Modified-since**:当资源过期了，发现响应头中具有Last-Modified声明，则再次发起请求的时候带上Last-Modified的时间，服务器收到请求后发现有lf-Modified-Since则与被请求资源的最后修改时间进行对比(Last-Modified)，如果最后修改时间(Last-Modified)较新(大)，说明资源又被改过，则返回最新资源，HTTP 200 OK;如果最后修改时间较旧（小)，说明资源无新修改，响应HTTP 304走缓存。

**2）请求头部中的If-None-Match字段与响应头部中的ETag字段**

- **响应头部中Etag**:唯一标识响应资源;
- **请求头部中的If-None-Match**:当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头If-None-Match值设置为Etag的值。服务器收到请求后进行比对，如果资源没有变化返回304(缓存)，如果资源变化了返回200(OK成功)。

### 长连接与短连接

#### HTTP长连接与短连接

**1）短连接**

==连接->传输数据->关闭连接==

​	**HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接**。也可以这样说：短连接是指**SOCKET连接后发送后接收完数据后马上断开连接**。

**2）长连接**

==连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。==

长连接指**建立SOCKET连接后不管是否使用都保持连接，但安全性较差**

**3）http的长连接**

- **HTTP也可以建立长连接的，使用`Connection:keep-alive`**，HTTP 1.1默认进行长连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了长连接支持(貌似最新的http1.0可以显示的指定keep-alive),但还是无状态的，或者说是不可以信任的。
- **长连接的好处**：一个网页上可能有多个资源对象，**长连接可以通过一个连接传输网页上的所有对象，而短连接每次连接只能传输一个对象，也就是一个网页的内容需要传输多次**

#### 什么时候用长连接，短连接？

- **长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况**。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：**数据库的连接用长连接**，如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。
- 而像**WEB网站的http服务一般都用短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以**并发量大，但每个用户无需频繁操作情况下需用短连好**。

#### 长连接的过期时间

客户端的长连接不可能无限期的拿着，会有一个超时时间，服务器有时候会告诉客户端超时时间，譬如：

![image-20250323002548956](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323002548956.png)

​	上图中的**Keep-Alive:timeout=20**，表示这个TCP通道可以保持20秒。另外还可能有max=XXX，表示这个长连接最多接收XXX次请求就断开。对于客户端来说，如果服务器没有告诉客户端超时时间也没关系，**服务端可能主动发起四次挥手断开TCP连接，客户端能够知道该TCP连接已经无效**；另外**TCP还有心跳包来检测当前连接是否还活着，方法很多，避免浪费资源**。

#### 长连接keepalive在HTTP还是在TCP

HTTP中与TCP中都存在keep-alive参数。http keep-alive与tcp keep-alive意图不一样。

- ==HTTP的Keepalive，是由**应用层（用户态）实现的**，称为HTTP长连接；==
- ==TCP的Keepalive，是由**TCP层（内核态）实现的**，称为TCP保活机制；==

**<u>1）http keep-alive</u>**

**①短连接**

​	**HTTP协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应**，由于HTTP是基于TCP传输协议实现的，客户端与服务端要进行HTTP通信前，需要先建立TCP连接，然后客户端发送HTTP请求，服务端收到后就返回响应，随后就会释放TCP连接。

l 如果是建立TCP -> 请求资源 -> 响应资源 -> 释放连接，那么此方式就是HTTP短连接

**②长连接**

​	为了让tcp活得更久一点，通过使用keep-alive机制，可以减少tcp连接建立次数，在同一个连接上传送多个http，提高socket的效率。HTTP长连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

在HTTP中的请求头设置，connection：keep-alive。

​	可以使用同一个TCP连接来发送和接收多个HTTP请求/应答，避免了连接建立和释放的开销，这个方法称为HTTP长连接

**<u>2）tcp keep-alive</u>**

是TCP的一种**检测TCP连接状况**的保活机制，**主要参数是`tcp keep-alive`**

​	在Linux内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：

- `tcp_keepalive_time=7200`：表示保活时间是7200秒（2小时），也就2小时内如果没有任何连接相关的活动，则会启动保活机制
- `tcp_keepalive_intvl=75`：表示每次检测间隔75秒；
- `tcp_keepalive_probes=9`：表示检测9次无响应，认为对方是不可达的，从而中断本次的连接

**具体过程：**

​	定义一个保活时间time，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔interval，发送一个探测报文，该探测报文包含的数据非常少，如果连续发送几个探测报文probes都没有得到响应，则认为当前的TCP连接已经死亡，就可以断开连接了。系统内核将错误信息通知给上层应用程序。

### Cookie的作用是什么？和Session有什么区别？

​	浏览器和服务器之间的通信是通过HTTP协议进行通信的，而**HTTP是无状态的协议**，不能保存客户的信息，即一次响应完成后就断开了，下一次的请求就需要重新连接，这样就需要判断是否是同一个客户，所以才需要**Cookie和Session 这种会话跟踪技术**。

#### Cookie与Session的区别

![image-20250323133316101](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323133316101.png)

![image-20250323133322207](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323133322207.png)

- 两者最大的区别在于**生存周期**：
  - **一个是IE启动到IE关闭.(浏览器页面一关,session就消失了)，**
  - **一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)**

![image-20250323133419487](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323133419487.png)

#### Cookie与Session的应用场景

![image-20250323133514280](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323133514280.png)

#### Session判断是否为同一个用户的常用方法

==核心使用的是SessionID==

![image-20250323133540825](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323133540825.png)

#### 如何使用Session-Cookie方案进行身份验证

很多时候我们都是通过SessionID来实现特定的用户，比如说

- **用户成功登陆系统，然后返回给客户端具有SessionID的Cookie。**
- **当用户向后端发起请求的时候会把SessionID带上，这样后端就知道你的身份状态了**。

**详细过程：**

1）用户向服务器发送用户名、密码、验证码用于登陆系统。

2）服务器验证通过后，服务器为用户创建一个Session，并将Session信息存储起来(通过redis等存储起来)。

3）服务器向用户返回一个SessionID，写入用户的Cookie。

4）当用户保持登录状态时，Cookie将与每个后续请求一起被发送出去。

5）服务器可以将存储在Cookie上的SessionID与存储在内存中或者数据库中的Session信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态

**使用Session的时候需要注意下面几个点：**

- 依赖Session的关键业务一定要确保客户端开启了Cookie。
- 注意Session的过期时间。

#### Cookie被禁用怎么办

​	一般是通过Cookie来保存SessionID，假如使用了Cookie保存SessionID的方案的话，如果客户端禁用了Cookie，那么Session就无法正常工作。

​	最常用的就是利用**URL重写把SessionID直接附加在URL路径的后面**。但是安全降低。当然，也**可以对SessionID进行一次加密之后再传入后端**

#### HTTP是不保存状态的协议，如何保存用户状态

​	HTTP是一种不保存状态，即**无状态（stateless）协议**。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。

​	Session机制的存在就是为了解决这个问题，Session的主要作用就是通过服务端记录用户的状态。**典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的**。**服务端给特定的用户创建特定的Session**，之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个Session，过了时间限制，就会销毁这个Session)。

​	在服务端保存Session的方法很多，最常用的就是内存和数据库(比如是使用**内存数据库redis保存**)。既然Session存放在服务器端，那么我们如何实现Session跟踪呢?大部分情况下，我们都是**通过在Cookie中附加一个Session ID来方式来跟踪**。

#### 多窗口应用的会话跟踪问题

​	在多窗口的应用中，服务器一般会采取Session Cookie和Persistent Cookie结合的方式来保证用户端的登陆状态不会失效。**在用户新开一个新窗口时，可以先把Session Cookie中的Session ID写入Persistent Cookie中，再通过新窗口读取，并发送通信请求**。这样就可以实现跨窗口的SessionTracking（会话追踪）。

#### 如果服务在多台服务器上，用session会有什么问题？如何解决？

- **使用独立的缓存器。**既将Session的数据存储在一个独立的服务器上。但是这样可能会有一些安全隐患，因此我们可以通过使用memcached分布式缓存服务器来进行存储。
- **服务器之间的Session不断传递和复制（Tomcat容器的采用方案）**。但这种方法有一种弊端，经人测试，web应用所能承载的并发数并没有因为服务器的增加而线性增加，甚至到达一个临界值时，新增服务器甚至会导致并发数的下降。原因是因为不同服务器间Session的传递和复制也会消耗系统资源，当服务器越多/用户请求越频繁，系统资源的消耗也会越来越大。
- **Session Cookie直接存储到Persistent Cookie中（早期淘宝采用的方案）**。但是这种方式不安全，容易遭受恶意截取Cookie等攻击。
- **Load Balancer-负载均衡器（硬件：F5；软件：LVS）**。负载均衡器可以分发请求，将用户请求均匀地发送到后台服务器。它还有一个特点，它可以记录每个Session ID对应的服务器。当带有Session ID的请求通过负载均衡器时，它会根据该值直接找到相对应的Web服务器。这种做法的专有名词叫做Sticky Session（Session粘滞）。不过这种做法也有一个弊端，当某个服务器挂掉的时候，其上存储的所有Session都会失效

#### (CSRF)为什么Cookie无法防止CSRF攻击，而Token可以

**CSRF(Cross Site Request Forgery)是指跨站请求伪造**

​	进行Session认证的时候，我们一般使用Cookie来存储SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，**服务端通过Redis或者其他存储工具记录保存着这个SessionId**，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。**如果别人通过Cookie拿到了SessionId后就可以代替你的身份访问系统了**

​	Session认证中Cookie中的SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果

​	但是，我们使用**Token**的话就不会存在这个问题，在我们登录成功获得Token之后，**可以选择存放在<font color = '#8D0101'>localStorage（浏览器本地存储）</font>中**。然后我们在前端通过某些方式会给每个发到后端的请求加上这个Token,这样就不会出现CSRF漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带Token的，所以这个请求将是非法的。

### HTTP与HTTPS

#### HTTP与HTTPS的区别

- **HTTP的端口号是80，HTTPS的端口号是443**。
- HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，在**TCP和HTTP网络层之间加入了SSL/TLS安全协议(SSL/TLS是运行在TCP之上)**，使得报文能够加密传输。
- HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而**HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输**。
- **HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的**。

![image-20250327170416004](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250327170416004.png)

#### HTTPS解决了HTTP的哪些问题、如何解决的

HTTP由于是明文传输，所以安全上存在以下三个风险：**窃听风险、篡改风险、冒充风险**

![image-20250327213453137](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250327213453137.png)

**HTTPS是如何解决上面的三个风险的**

- **混合加密**的方式实现信息的机密性，解决了窃听的风险。
- **摘要算法**的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

#### HTTPS秘钥加密，对称和非对称加密

​	HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密（采用对称和非对称两种加密方式相结合的加密方式)。所以说，HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。

<u>**1)对称秘钥加密**</u>

​	这种加密方式的加密算法是公开的，密钥是保密的，加密和解密采用同一个密钥，也就是任何人得到了密钥就能进行加密和解密。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。

**弊端**：在进行通信时，也必须把密钥发送给对方，否则对方无法解密。而在把密钥发给对方的过程中，就存在安全问题。

<u>**2)非对称密钥加密**</u>

​	这种加密方式有两种密钥，一种公钥，可以公开告诉任何人，一把私钥，只能自己持有。它们两个必需配对使用，否则不能打开加密文件。发送双方A，B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密，B向A发送消息时为同样的道理。

**弊端**：使用公钥对消息加密速度比较慢

<u>**3）混合加密**</u>

**混合加密**的方式实现信息的**机密性**，解决了窃听的风险。

1）HTTPS采用的是**对称加密和非对称加密结合**的「**混合加密**」方式：

- 在**通信建立前采用非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。**用于在握手过程中加密生成的密码**
- 在**通信过程中全部使用对称加密**的「会话秘钥」的方式加密明文数据。**用于对真正传输的数据进行加密**



## TCP篇（传输层）

### TCP基本认识

TCP是<font color = '#8D0101'>**面向连接的、可靠的、基于字节流**</font>的传输层通信协议

- **面向连接**：一定是**「一对一」才能连接**，不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP都可以**保证一个报文一定能够到达接收端**；
- **字节流**：用户消息通过TCP协议传输时，消息可能会被操作系统「分组」成多个的TCP报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且TCP报文是「有序的」，当「前一个」TCP报文没有收到的时候，即使它先收到了后面的TCP报文，那么也不能扔给应用层去处理，同时对「重复」的TCP报文会自动丢弃。

#### 什么是TCP连接

​	连接的定义：**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接**

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps66.jpg) 

所以我们可以知道，建立一个TCP连接是需要客户端与服务器端达成上述三个信息的共识。

- **Socket**：由**IP地址和端口号**组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

#### 如何唯一确定一个TCP连接

TCP四元组可以唯一的确定一个连接，四元组包括如下：**源地址、源端口、目的地址、目的端口**

![image-20250323135906770](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323135906770.png)

- **源地址和目的地址的字段（32位）是在IP头部中**，作用是通过IP协议发送报文给**对方主机**。
- **源端口和目的端口的字段（16位）是在TCP头部中**，作用是告诉TCP协议应该把报文发给哪个**进程**

#### 有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？

![image-20250323140140564](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323140140564.png)

![image-20250323140158965](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323140158965.png)

#### TCP头部格式

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323140505265.png" alt="image-20250323140505265" style="zoom:55%;" />

如果不算选项（长度可变），**TCP头部长度为20字节**，算上选项（长度可变），**最多为60字节**。

**1）序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，**每发送一次数据，就「累加」一次该「数据字节数」的大小**。用来解决网络包乱序问题。

**2）确认应答号**：指**下一次「期望」收到的数据的序列号**，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

**3）控制位：**

- **ACK：**该位为1时，「确认应答」的字段变为有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。
- **RST：**该位为1时，表示TCP连接中出现异常必须强制断开连接。
- **SYN：**该位为1时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- **FIN：**该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位为1的TCP段。

#### UDP头部格式

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps68.jpg) 

**UDP头部固定为8字节**

- **目标和源端口**：主要是告诉UDP协议应该把报文发给哪个进程。
- **包长度**：该字段保存了UDP首部的长度跟数据的长度之和。
- **校验和**：校验和是为了提供可靠的UDP首部和数据而设计，防止收到在网络传输中受损的UDP包。

### TCP和UDP

#### TCP和UDP区别

![image-20250323174434379](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323174434379.png)

![image-20250323174510026](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323174510026.png)

![image-20250323174514749](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323174514749.png)

![image-20250323174517582](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323174517582.png)

#### TCP和UDP应用场景

1）由于TCP是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP文件传输；
- HTTP/HTTPS；

2）由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如DNS、SNMP等；
- 视频、音频等多媒体通信；
- 广播通信

#### UDP如何实现可靠传输

​	首先UDP在设计定义时就是无连接的，只管发送，不管回执/反馈，可靠性由上层应用实现，所以要实现udp可靠性传输，必须通过应用层来实现和控制。

**1.应用层控制**

- 自定义通讯协议，在应用层定义一些可靠的协议，比如检测包的顺序，重复包等问题，如果没有收到对方的ACK，重新发包,将实现放到应用层，然后类似于TCP，实现确认机制、重传机制和窗口确认机制。
- 给数据包进行编号，按顺序接收并存储，接收端收到数据包后发送确认信息给发送端，发送端接收到确认信息后继续发送，若接收端接收的数据不是期望的顺序编号，则要求重发；（主要解决丢包和包无序的问题)。

**==(TCP如何实现可靠传输)==**

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps69.jpg) 

​	当然这样会有重复造轮子的感觉，所有要想可靠传输，可以使用TCP，或者使用基于UDP协议的QUIC协议，现在已经应用在了HTTP/3上。

#### 聊天服务器选择TCP还是UDP、内网聊天服务器选择什么

**<u>==1）QQ的解决方案：udp为主，tcp为辅==</u>**

- 首先每一个客户实际上都适合服务器交互，再有服务器转发给正在通信的用户
  - 如果每一个QQ从一上线到下线的这段时间全部采用TCP长连接，这对服务器的负担很大；
  - 而如果采用TCP短连接，频繁的连接断开也会造成网络负担，
  - 而采用UDP可以避开上面麻烦，减少服务的负担
- 不管是TCP还是UDP，**最终登录成功之后，QQ都会有一个TCP连接来保持在线状态**。UDP协议是无连接方式的协议，它的效率高、速度快、占用资源少，但是其传输机制为不可靠传输，必须依靠辅助的算法来完成传输控制。**QQ采用的通信协议以UDP为主，TCP为辅**。由于QQ服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器只有采用UDP协议与客户端进行通信才能保证这种大规模的服务。
- **QQ客户端之间的消息传输也采用了UDP模式**，因为国内的网络环境复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间彼此能够建立起来TCP连接的概率较小，严重影响传输信息的效率。而UDP包能够穿透大部分的代理服务器，因此QQ选择了UDP作为客户端之间的主要通信协议
- **采用UDP协议，通过服务器中转方式**。因此，限制的IP探测在你仅仅跟对方发送聊天消息的时候是无法获取到IP的。大家都知道，UDP协议是不可靠的协议，只管发送，不管对方是否能够收到，但传输高效。但是，作为聊天软件是必须可靠的。所以，QQ采用了上层协议来保证可靠传输：如果客户端使用UDP协议发出消息之后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输。之所以会发生在客户端明明看到“消息发送失败”但对方又收到了这个消息的情况，就是因为客户端发出的消息服务器已经收到并转发成功，但客户端由于网络原因没有收到服务器的应答包引起的

**2）内网聊天**

- 文件传输用TCP
- 信息发送使用UDP，因为内网基本不会发送丢包问题。

### TCP的状态流转(就是客户端和服务端经历握手和挥手过程的状态变化过程)

**<u>【客户端】</u>**

![image-20250323175603043](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323175603043.png)

![image-20250323175607463](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323175607463.png)

**<u>【服务端状态流转】</u>**

![image-20250323181543194](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323181543194.png)

![image-20250323181615167](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323181615167.png)

### TCP连接建立（三次握手）

#### TCP三次握手

**三次握手建立连接的首要目的是<font color = '#8D0101'>「同步序列号」</font>**

- **序列号(SEQ)**：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，**每发送一次数据，就「累加」一次该「数据字节数」的大小**。用来解决网络包乱序问题。
- **初始序列号(ISN)**，在TCP建立连接的时候，**客户端和服务端都会各自生成一个初始序列号**，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个32位的计数器，该计数器的数值每4微秒加1，循环一次需要4.55小时。

​	TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手来进行的。三次握手的过程如下图：

![image-20250323182124059](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323182124059.png)

- 一开始，客户端和服务端都处于**CLOSED状态**。先是**服务端主动监听某个端口，处于LISTEN状态**。

- **客户端会随机初始化序号（client_isn）**，将此序号置于**TCP首部的「序列号」字段Seq Num中**，同时把**SYN标志位置为1，表示SYN报文**。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后**客户端处于SYN-SENT状态**。

  ![image-20250323182642162](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323182642162.png)

- 服务端收到客户端的SYN报文后，首先**服务端也随机初始化自己的序号（server_isn）**，将此序号填入**TCP首部的「序列号」字段Seq Num中**，其次把**客户端传来的序号加一(client_isn+1)**填入TCP首部的「**确认应答号」字段ACK Num**，接着**把SYN和ACK标志位置为1**。最后把该报文发给客户端，该报文也不包含应用层数据，之后**服务端处于SYN-RCVD状态**。

  ![image-20250323182839104](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323182839104.png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该**应答报文TCP首部ACK标志位置为1**，其次把**服务端传来的序号加一(server_isn+1)填入「确认应答号」字段ACK Num**，最后把报文发送给服务端，==这次报文可以携带客户到服务器的数据==，之后**客户端处于ESTABLISHED状态**。

  ![image-20250323182939907](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323182939907.png)

- **服务器**收到客户端的应答报文后，也进入**ESTABLISHED状态**

**【为何第三次握手可以携带数据】**

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**

1） **如果有携带数据**：下次客户端发送的报文，Seq Num=服务器发回的ACK Num号

2）**如果没有携带数据**：那么第三次握手的报文不消耗seq。下次客户端发送的报文，seq序列号还是和第三次握手的报文的seq一样，为client_isn+1

#### 为什么需要三次握手

**<u>1.总结</u>**

- **「两次握手」**：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

- **「四次握手」**：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

  ![image-20250323183300730](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323183300730.png)

**<u>2.具体</u>**

<u>1）因为三次握手才能**保证双方具有接收和发送的能力**（这是最基本的原因）</u>

<u>2）**三次握手才可以阻止重复历史连接的建立**（主要原因）</u>

**【正常情况】**

客户端连续发送多次SYN建立连接的报文，在**网络拥堵**情况下：

- 一个「旧SYN报文」比「最新的SYN」报文早到达了服务端；
- 那么此时服务端就会回一个SYN+ACK报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送RST报文给服务端，表示中止这一次连接。

**【两次握手的情况】**

​	**如果是两次握手连接，**就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端就有足够的上下文来判断当前连接是否是历史连接：

- **如果是历史连接**（序列号过期或超时），则第三次握手发送的报文是RST报文，以此中止历史连接；
- **如果不是历史连接**，则第三次发送的报文是ACK报文，通信双方就会成功建立连接；

​	**在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费**

<u>3）三次握手才可以**同步双方的初始序列号**</u>

![image-20250323184739782](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323184739782.png)

- 当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步**。
- 而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

<u>4）三次握手才可以**避免资源浪费**</u>

- 如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
- 而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

![image-20250323184902214](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323184902214.png)

#### 为什么每次建立TCP连接时，初始化的序列号都要求不一样

主要原因有两个方面：

1）为了防止历史报文被下一个相同四元组(唯一确定一个连接)的连接接收（主要方面），**但是并不是完全避免了：因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文**；

- 如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。

2）为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收；

- 四元组：源IP地址、源端口、目的IP地址、目的端口

> [!CAUTION]
>
> - **序列号(SEQ)**，是TCP一个头部字段，标识了TCP发送端到TCP接收端的数据流的一个字节，因为TCP是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个32位的无符号数，因此在到达4G之后再循环回到0。
> - **初始序列号(ISN)**，在TCP建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个32位的计数器，该计数器的数值每4微秒加1，循环一次需要4.55小时。

#### (MTU和MSS)既然IP层会分片，为什么TCP层还需要MSS呢

- ==**MTU**：一个网络包的最大长度，以太网中一般为1500字节；==
- ==**MSS**：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度；==

​	若在IP层进行切片，那么当**如果一个IP分片丢失，整个IP报文的所有分片都得重传**。因为IP层本身没有超时重传机制，它由传输层的TCP来负责超时重传。

​	当接收方发现TCP报文（头部+数据）的某一片丢失后，就不会响应ACK给对方，那么发送方的TCP在超时后，就会重发「整个TCP报文（头部+数据）」。因此由IP层进行分片传输，是非常没有效率的。

- 所以TCP协议在**建立连接的时候通常要协商双方的MSS值**，当TCP层发现数据超过MSS时，则就先会进行分片，当然由它形成的IP包的长度也就不会大于MTU，自然也就不用IP分片了。

- 经过TCP层分片后，如果一个TCP分片丢失后，**进行重发时也是以MSS为单位**，而不用重传所有的分片，大大增加了重传的效率。

#### 握手丢失会发生什么？

**<u>1．第一次握手丢失</u>**

​	首先第一个发的就是SYN报文，也就是说第一个SYN报文丢失，那么客户端迟迟收不到服务端的SYN-ACK报文（第二次握手），就会触发**「超时重传」**机制，**重传SYN报文**，那么到底重发几次呢：

- 在Linux里，客户端的SYN报文最大重传次数由 tcp syn retries内核参数控制，这个参数是可以自定义的，默认值一般是5.
- 通常，第一次超时重传是在1秒后，第二次超时重传是在2秒，第三次超时重传是在4秒后，第四次超时重传是在8秒后，第五次是在超时重传16秒后。没错，**每次超时的时间是上一次的2倍**。

**<u>2．第二次握手丢失</u>**

第二次握手就是：当服务端收到客户端的第一次握手后，就会回SYN-ACK报文给客户端，此时服务端会进入SYN_RCVD状态

第二次握手的SYN-ACK报文有两个目的：

- **一个是ACK，是对第一次握手的确认报文；**
- **另一个是SYN，是服务端发起建立TCP连接的报文；**

**【当第二次握手丢失了，客户端和服务端都会重传】**

- **客户端会重传SYN报文，也就是第一次握手**，最大重传次数由 tcp_syn_retries内核参数决定；
  - 因为第二次握手报文里是包含对客户端的第一次握手的ACK确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的SYN报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传SYN报文**。
- **服务端会重传SYN-ACK报文，也就是第二次握手**，最大重传次数由 tcp_synack_retries 内核参数决定。
  - 如果第二次握手丢失了，服务端就收不到第三次握手(TCP发送的ACK报文)，于是**服务端这边会触发超时重传机制，重传SYN-ACK报文**

**<u>3．第三次握手丢失</u>**

- **第三次握手的ACK是对第二次握手的SYN的确认报文**，如果服务端那一方迟迟收不到这个确认报文，就会**触发超时重传机制，服务端重传SYN-ACK报文，直到收到第三次握手，或者达到最大重传次数**。

#### SYN泛洪攻击及避免

​	TCP连接建立是需要三次握手，假设攻击者短时间伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但**服务端发送出去的ACK + SYN报文，无法得到未知IP主机的ACK应答，一直这样就会<font color = '#8D0101'>占满服务端的半连接队列（SYN队列）</font>，使得服务器不能为正常用户服务**。

**【正常流程】**

**<font color = '#8D0101'>Linux内核</font>的SYN队列（半连接队列）与Accpet队列（全连接队列）的工作流程**

- 当服务端接收到客户端的SYN报文时，会将其加入到内核的**「SYN队列」**；
- 接着发送SYN + ACK给客户端，等待客户端回应ACK报文；
- 服务端接收到ACK报文后，从「SYN队列」移除放入到**「Accept队列」**；
- 应用通过调用**accpet() socket接口**，从「Accept队列」取出连接。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323201138834.png" alt="image-20250323201138834" style="zoom:50%;" />

**【如何避免SYN泛洪攻击】**

1） **降低SYN timeout时间**，使得主机尽快释放半连接的占用

2）其中一种解决方式是通过**修改Linux内核参数，控制队列大小和当队列满时应做什么处理**

3）如果不断受到SYN攻击，就会导致SYN队列（半连接队列）被占满，从而导致无法在建立新的连接，可以采用**SYN cookie设置(tcp_syncookies)来应对SYN攻击，就是如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文**。

4）采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击

### TCP连接的断开（四次挥手）

#### 四次挥手的过程

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323201413887.png" alt="image-20250323201413887" style="zoom:45%;" />

- **客户端**打算关闭连接，此时会发送一个**TCP首部FIN标志位被置为1的报文，也即<font color = '#8D0101'>FIN报文</font>**，之后**客户端进入<font color = '#8D0101'>FIN_WAIT_1</font>状态**。
- **服务端**收到该报文后，就向客户端**发送ACK应答报文**，接着**服务端进入<font color = '#8D0101'>CLOSED_WAIT</font>状态**。
- **客户端**收到服务端的ACK应答报文后，之后进入**<font color = '#8D0101'>FIN_WAIT_2</font>状态**。
- 等待**服务端**处理完数据后，也**向客户端发送FIN报文**，之后**服务端进入<font color = '#8D0101'>LAST_ACK状态</font>**。
- **客户端**收到服务端的FIN报文后**，回一个ACK应答报文**，之后进入**<font color = '#8D0101'>TIME_WAIT状态</font>**
- **服务器**收到了ACK应答报文后，**就进入了<font color = '#8D0101'>CLOSED状态</font>**，至此服务端已经完成连接的关闭。
- **客户端**在经过<font color = '#8D0101'>**2MSL（报文最大生存时间）**</font>一段时间后，**自动进入<font color = '#8D0101'>CLOSED状态</font>**，至此客户端也完成连接的关闭。

这里一点需要注意是：**<font color = '#8D0101'>主动关闭连接的，才有TIME_WAIT状态。</font>**

#### 四次挥手的含义

**每个方向都需要一个FIN和一个ACK，因此通常被称为四次挥手**。

- **第一次挥手∶**由客户端向服务端发起的，这时客户端完成了数据发送，会发起一个包，去进行连接断开的请求，这个数据包中的FIN位为1.
- **第二次挥手:**由服务器发送给客户端的.是用来确认客户端断开连接请求的一个数据包.所以是一个ACK数据包;
- **第三次挥手**:由服务器发送给客户端的，这个时候如果服务端也发送完毕的话，也会向客户端发起一个断开连接的申请,这个请求中的FIN位同样会被标记为1;
- **第四次挥手:**由客户端发送给服务器的，是用来确认服务端上一次的请求断开连接。发送出一个ACK标志为1的报文。

#### 为什么需要四次挥手

**<font color = '#8D0101'>服务端的ACK和FIN一般都会分开发送</font>，这是因为<font color = '#8D0101'>服务端通常需要等待完成数据的发送和处理</font>**，从而比三次握手导致多了一次

- 关闭连接时，客户端向服务端发送FIN时，**仅仅表示客户端不再发送数据了但是还能接收数据**。
- 服务器收到客户端的FIN报文时，先回一个ACK应答报文，而**服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送FIN报文给客户端来表示同意现在关闭连接

#### 挥手丢失会发生什么

**<u>1）第一次挥手丢失</u>**

- 如果第一次挥手丢失(向服务端发送的FIN报文丢失)了，**那么<font color = '#8D0101'>客户端</font>迟迟收不到被动方的ACK的话**，也就会**触发<font color = '#8D0101'>超时重传机制，重传FIN报文</font>，重发次数由tcp_orphan_retries参数控制**。当客户端重传FIN报文的次数超过tcp_orphan_retries后，就不再发送FIN报文，直接进入到close状态。

**<u>2）第二次挥手丢失</u>**

- **ACK报文是不会重传的**，所以如果服务端的第二次挥手(发送给客户端的ACK丢失)丢失了，**<font color = '#8D0101'>客户端就会触发超时重传机制，重传FIN报文</font>**，直到收到服务端的第二次挥手，或者达到最大的重传次数

**<u>3）第三次挥手丢失</u>**

- 服务端处于CLOSE_WAIT状态时，调用了close函数，内核就会发出FIN报文，同时连接进入LAST_ACK状态，**等待客户端返回ACK来确认连接关闭如果迟迟收不到这个ACK，<font color = '#8D0101'>服务端就会重发FIN报文</font>**，重发次数仍然由tcp_orphan_retries参数控制，这与客户端重发FIN报文的重传次数控制方式是一样的。

**<u>4）第四次挥手丢失</u>**

- 当客户端收到服务端的第三次挥手的FIN报文后，就会回ACK报文，也就是第四次挥手，此时客户端连接进入TIME_WAIT状态。然后，服务端（被动关闭方）没有收到ACK报文前，还是处于LAST_ACK状态。**如果第四次挥手的ACK报文没有到达服务端，<font color = '#8D0101'>服务端就会重发FIN报文</font>，重发次数仍然由前面介绍过的tcp_orphan_retries参数控制**。

#### 为什么需要TIME_WAIT状态

需要TIME-WAIT状态，主要是两个原因：

1）**防止历史连接中的数据，被后面相同四元组的连接错误的接收**；

- **序列号SEQ Num和初始化序列号ISN并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**
- TCP设计了TIME_WAIT状态，状态会持续**<font color = '#8D0101'>2MSL(报文最大生存时间)</font>**，这个时间足以让本次连接产生的所有报文段都从网络中消失都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

2） **保证「被动关闭连接」的一方，能被正确的关闭**；

- TIME-WAIT作用是等待足够的时间以确保最后的ACK报文能让被动关闭方接收，从而帮助其正常关闭。

#### 为什么TIME_WAIT等待时间是2MSL

​	TIME_WAIT等待2倍的MSL(**报文最大生存时间**)：**网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<font color = '#8D0101'>一来一回需要等待2倍的时间</font>**。

​	可以看到2MSL时长这其实是相当于**至少允许报文丢失一次**。比如，若ACK在一个MSL内丢失，这样被动方重发的FIN会在第2个MSL内到达，TIME_WAIT状态的连接可以应对。

​	2MSL的时间是**从客户端接收到FIN后发送ACK开始计时的**。如果在**TIME-WAIT时间内**，因为客户端的ACK没有传输到服务端，客户端又接收到了服务端重发的FIN报文，那么2MSL时间将重新计时。

#### MSL与TTL的区别

​	<font color = '#8D0101'>**MSL是Maximum Segment Lifetime，报文最大生存时间**</font>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，**<font color = '#8D0101'>而IP头中有一个TTL字段，是IP数据报可以经过的最大路由数</font>**，**每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机**。 

- **MSL与TTL的区别**：**MSL的单位是时间，而TTL是经过路由跳数**。所以MSL应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。

​	**TTL的值一般是64，Linux将MSL设置为30秒，意味着Linux认为数据报文经过64个路由器的时间不会超过30秒，如果超过了，就认为报文已经消失在网络中了。<font color = '#8D0101'>Linux系统停留在TIME_WAIT的时间为固定的60秒</font>**。

#### TIME_WAIT过多有什么危害

**过多的TIME-WAIT状态主要的危害有两种**

- 第一是<font color = '#8D0101'>**内存资源占用**</font>；
- 第二就是主要的危害：对<font color = '#8D0101'>**端口资源的占用**</font>，一个TCP连接至少消耗「发起连接方」的一个本地端口；

​	第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为32768～61000。

**占用端口资源导致的后果**

1）客户端（发起连接方）受端口资源限制：

- **如果客户端「发起连接方」的TIME_WAIT状态过多，占满了所有端口资源，则会导致无法创建新连接。**

2）服务端（被动连接方）受系统资源限制：

- 由于一个四元组表示TCP连接，理论上服务端可以建立很多连接，因为服务端只监听一个端口，不会因为TCP连接过多而导致端口资源受限。但是TCP连接过多，**会占用系统资源**，比如文件描述符、内存资源、CPU资源、线程资源等

### (TCP保活 tcp keep-alive)建立了连接，但是客户端突然出现故障

​	TCP有一个**检测TCP连接状况**的保活机制，主要参数为tcp keep-alive

​	在Linux内核可以有对应的参数可以设置**保活时间、保活探测的次数、保活探测的时间间隔**，以下都为默认值：

- tcp_keepalive_time=7200：表示保活时间是7200秒（2小时），也就2小时内如果没有任何连接相关的活动，则会启动保活机制
- tcp_keepalive_intvl=75：表示每次检测间隔75秒；
- tcp_keepalive_probes=9：表示检测9次无响应，认为对方是不可达的，从而中断本次的连接

【**具体过程**】

​	定义一个保活时间time，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔interval，发送一个探测报文，该探测报文包含的数据非常少，如果连续发送几个探测报文proves都没有得到响应，则认为当前的TCP连接已经死亡，就可以断开连接了。系统内核将错误信息通知给上层应用程序

### TCP协议如何保证可靠传输

TCP实现可靠传输的方式之一，通过序列号与确认应答。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps70.jpg) 

### TCP的机制(保证可靠性)

#### 重传机制（超时重传、快速重传）（RTT往返时延、RTO超时重传时间）

**【超时重传】**

​	重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。 

TCP会在以下两种情况发生超时重传：**<font color = '#8D0101'>数据包丢失、确认应答丢失</font>**

**==超时重传时间应该设置为多少呢？==**

​	**<font color = '#8D0101'>RTT(Round-Trip Time往返时延)</font>**：就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。

​	**超时重传时间是以<font color = '#8D0101'>RTO(Retransmission Timeout超时重传时间)</font>**表示。

假设在重传的情况下，超时时间RTO「较长或较短」时，会发生什么事情？

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps75.jpg) 

因此：**<font color = '#8D0101'>超时重传时间RTO的值应该略大于报文往返RTT的值</font>**

**【快速重传】**

​	TCP还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。比如**发送方收到了三次同样的ACK确认报文，于是就会触发快速重发机制**

​	快速重传机制只解决超时时间的问题，但是它没有解决一个问题就是重传的时候，是**重传之前的一个包，还是重传所有包的问题**。



#### 滑动窗口

​	**TCP是每发送一个数据，都要进行一次确认应答，所以数据包的往返时间越长，通信的效率就越低**。**<font color = '#8D0101'>TCP头里有一个字段window，就是滑动窗口的大小</font>**，所以即使在往返时间较长的情况下，它也不会降低网络通信的效率。

- 这个window字段是**接收端告诉发送端自己还有多少缓冲区可以接收数据**。于是**发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来的这种情况**
- **窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。**如果按期收到确认应答，此时数据就可以从缓存区清除。

**<u>【窗口的大小由哪一方决定】</u>**

​	**窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值**，通常**窗口的大小是由接收方的窗口大小来决定的**，发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

**【接收窗口和发送窗口的大小是相等的吗】**

- 并不是完全相等，**接收窗口的大小是<font color = '#8D0101'>约等于</font>发送窗口的大小的**。
- 因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过TCP 报文中的 Windows 宇段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

**【什么是拥塞窗口？和发送窗口有什么关系呢？】**

**拥塞窗口 cwnd**是**发送方**维护的一个的状态变量，它会**根据网络的拥塞程度动态变化**的。

​	我们在前面提到过发送窗口 swnd 和接收窗口 rwnd是约等于的关系，那么由于加入了拥塞窗口的概念后，此时**发送窗口的值是swnd =min（cwnd, rwnd）**，也就是拥塞窗口和接收窗口中的最小值。

**拥塞窗口 cwnd 变化的规则**：

- 只要网络中没有出现拥塞，cwnd 就会增大；
- 但网络中出现了拥塞，cwnd 就减少；

#### 流量控制

​	发送方不能一直自顾自地发数据给接收方，要考虑接收方处理能力。

​	**TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制**。

##### 操作系统缓冲区与滑动窗口的关系

​	前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，**发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的**，而操作系统的缓冲区，会被操作系统调整。

当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。

所以，如果发生了**先减少缓存，再收缩窗口，就会出现丢包的现象**。

​	**为了防止这种情况发生，TCP规定是不允许同时减少缓存又收缩窗口的，而是采用<font color = '#8D0101'>先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况</font>**。

##### 窗口关闭

​	在前面我们都看到了，TCP通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

​	**如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0为止，这就是窗口关闭**。

**【窗口关闭潜在的死锁风险】**

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324123246297.png" alt="image-20250324123246297" style="zoom:60%;" />

- 接收方向发送方通告窗口大小时，是**通过ACK报文**来通告的。
- 那么，当发生窗口关闭时，接收方处理完数据后，**会向发送方通告一个窗口非0的ACK报文**，**如果这个通告窗口的ACK报文在网络中丢失了**，那麻烦就大了。
- 这会**导致发送方一直直待接收方的非0窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了<font color = '#8D0101'>死锁</font>的现象**

**【通过定时器解决潜在的死锁问题】**

​	为了解决这个问题，**TCP为每个连接设有一个<font color = '#8D0101'>定时器</font>**，只要**TCP连接一方收到对方的零窗口通知，就启动持续计时器**。如果持续计时器超时，就会发送**窗口探测(Window probe)报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

- 如果接收窗口仍然为0，那么收到这个报文的一方就会重新启动持续计时器；
- 如果接收窗口不是0，那么死锁的局面就可以被打破了。

​	窗口探测的次数一般为3次，每次大约30-60秒（不同的实现可能会不一样）。如果3次过后接收窗口还是0的话，有的TCP实现就会发RST报文来中断连接。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324123603189.png" alt="image-20250324123603189" style="zoom:60%;" />

#### 拥塞控制

​	前面的**流量控制是避免「发送方」的数据填满「接收方」的缓存**，但是并不知道网络的中发生了什么。	

​	**<font color = '#8D0101'>拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络</font>**，为了在「发送方」调节所要发送数据的量，定义了一个叫做**<font color = '#8D0101'>「拥塞窗口」</font>**的概念

**【什么是拥塞窗口？和发送窗口有什么关系呢？】**

**拥塞窗口 cwnd**是**发送方**维护的一个的状态变量，它会**根据网络的拥塞程度动态变化**的。

​	我们在前面提到过发送窗口 swnd 和接收窗口 rwnd是约等于的关系，那么由于加入了拥塞窗口的概念后，此时**发送窗口的值是swnd =min（cwnd, rwnd）**，也就是拥塞窗口和接收窗口中的最小值。

**拥塞窗口 cwnd 变化的规则**：

- 只要网络中没有出现拥塞，cwnd 就会增大；
- 但网络中出现了拥塞，cwnd 就减少；

**【拥塞控制的四个算法】**

##### 慢启动算法

TCP在刚建立连接完成后，首先是有个慢启动的过程

这里**假定拥塞窗口cwnd(crowd window)和发送窗口swnd(send window)相等**，下面举个栗子：

- 连接建立完成后，一开始初始化cwnd=1，表示可以传一个**MSS大小的数据**。
- 当收到一个ACK确认应答后，cwnd增加1，于是一次能够发送2个
- 当收到2个的ACK确认应答后，cwnd增加2，于是就可以比之前多发2个，所以这一次能够发送4个
- 当这4个的ACK确认到来的时候，每个确认cwnd增加1，4个确认cwnd增加4，于是就可以比之前多发4个，所以这一次能够发送8个。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324124251375.png" alt="image-20250324124251375" style="zoom:60%;" />

有一个叫**<font color = '#8D0101'>慢启动门限ssthresh</font>**（slow start threshold）状态变量。

- ==**当cwnd < ssthresh时，使用慢启动算法。**==
- ==**当cwnd >= ssthresh时，就会使用「拥塞避免算法」**。==

##### 拥塞避免算法

当拥塞窗口cwnd「超过」慢启动门限ssthresh就会进入拥塞避免算法

​	那么进入拥塞避免算法后，它的规则是：**<font color = '#8D0101'>每当收到一个ACK时，cwnd增加1/cwnd,也就是说变成了一个线性增长</font>**。

- Eg：当8个ACK应答确认到来时，每个确认增加1/8，8个ACK确认cwnd一共增加1，于是这一次能够发送9个MSS大小的数据，变成了线性增长。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324124617298.png" alt="image-20250324124617298" style="zoom:60%;" />

​	所以，拥塞避免算法就是**<font color = '#8D0101'>将原本慢启动算法的指数增长变成了线性增长</font>**，还是增长阶段，但是增长速度缓慢了一些。

​	就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

**<font color = '#8D0101'>当触发了重传机制，也就进入了「拥塞发生算法」</font>**。

##### 拥塞发生算法(包括超时重传和快速重传)

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- **超时重传**
- **快速重传**

**<u>1）发生超时重传的拥塞发生算法</u>**

当发生了「超时重传」，则就会使用拥塞发生算法，这个时候，ssthresh和cwnd的值会发生变化：

- **ssthresh(慢启动门限)设为cwnd/2**
- **cwnd(拥塞窗口)重置为1（是恢复为cwnd初始化值，我这里假定cwnd初始化值1）**

​	接着，就重新开始慢启动，慢启动是会突然减少数据流的。这种方式太激进了，反应也很强烈，会造成网络卡顿

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324125003262.png" alt="image-20250324125003262" style="zoom:60%;" />

<u>**2）发生快速重传的拥塞发生算法**</u>

​	还有更好的方式，前面我们讲过**「快速重传算法」**。当接收方发现丢了一个中间包的时候，发送三次前一个包的ACK，于是发送端就会快速地重传，不必等待超时再重传。

​	TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，则ssthresh(慢启动门限)和cwnd变化如下：

- **cwnd = cwnd/2，也就是设置为原来的一半;**
- **ssthresh = cwnd;**
- **进入快速恢复算法**

##### 快速恢复

​	**快速重传和快速恢复算法一般同时使用**，快速恢复算法是认为，你还能收到3个重复ACK说明网络也不那么糟糕，所以没有必要用超时重传算法(RTO(Retransmission Timeout):重新传输超时时间)。

正如前面所说，进入快速恢复之前，cwnd和ssthresh已被更新了：

- **cwnd = cwnd/2，也就是设置为原来的一半;**
- **ssthresh = cwnd;**

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324125713494.png" alt="image-20250324125713494" style="zoom:67%;" />

进入快速恢复算法如下：

- 拥塞窗口cwnd = ssthresh + 3（3的意思是确认有3个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的ACK，那么cwnd增加1；这个过程的目的是尽快将丢失的数据包发给目标
- 如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh的值，原因是该ACK确认了新的数据，说明从duplicated ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

> [!CAUTION]
>
> - 首先，快速恢复是拥塞发生后慢启动的优化，其**首要目的仍然是降低cwnd来减缓拥塞，所以必然会出现cwnd从大到小的改变**。
> - 其次，过程2（cwnd逐渐加1）的存在是为了**尽快将丢失的数据包发给目标**，**从而解决拥塞的根本问题（三次相同的ACK导致的快速重传），所以这一过程中cwnd反而是逐渐增大的**

### ARQ协议（自动重传请求）

​	**<font color = '#8D0101'>自动重传请求（Automatic Repeat-reQuest，ARQ</font>）**是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。**ARQ包括<font color = '#8D0101'>停止等待ARQ协议和连续ARQ协议</font>**。

#### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

优缺点：

- 优点：简单
- 缺点：信道利用率低，等待时间长

#### 连续ARQ协议

​	连续ARQ协议可**提高信道利用率**。**发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认**。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优缺点：**

- 优点：信道利用率高，容易实现，即使确认丢失，也不必重传。
- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了5 条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。

### TCP协议有什么缺陷及解决方法

#### TCP缺陷

**<u>1）TCP建立连接有很大延迟</u>**

​	基于TCP实现的应用协议，都是需要先建立三次握手才能进行数据传输，比如HTTP 1.0/1.1、HTTP/2、HTTPS。现在大多数网站都是使用HTTPS的，这意味着在TCP三次握手之后，还需要经过TLS四次握手后，才能进行HTTP数据的传输，这在一定程序上增加了数据传输的延迟。

**<u>2）TCP存在队头阻塞问题</u>**

​	HTTP/2多个请求是跑在一个TCP连接中的，那么当TCP丢包时，整个TCP都要等待重传，那么就会阻塞该TCP连接中的所有请求，所以HTTP/2队头阻塞问题就是因为TCP协议导致的(HTTP2解决了应用层层面的队头阻塞，但是还是有tcp层层面的队头阻塞)

​	因为TCP是字节流协议，**TCP层必须保证收到的字节数据是完整且有序的**，如果序列号较低的TCP段在网络传输中丢失了，即使序列号较高的TCP段已经被接收了，应用层也无法从内核中读取到这部分数据，所以需要重传操作，就导致了队头阻塞

> [!NOTE]
>
> ![image-20250324131032431](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324131032431.png)
>
> ​	图中发送方发送了很多个packet，每个packet都有自己的序号，你可以认为是TCP的序列号，其中packet #3在网络中丢失了，即使packet #4-6被接收方收到后，由于内核中的TCP数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到packet #3重传后，接收方的应用层才可以从内核中读取到数据。

**<u>3）网络迁移需要重新建立TCP连接</u>**

​	基于TCP传输协议的HTTP协议，由于是**通过四元组（源IP、源端口、目的IP、目的端口）确定一条TCP连接**。

​	**那么当移动设备的网络从4G切换到WIFI时，意味着IP地址变化了，那么就必须要断开连接，然后重新建立TCP连接**

​	而**建立连接的过程包含TCP三次握手和TLS四次握手的时延**，以及TCP慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的

**<u>4）升级TCP的工作很困难</u>**

​	但是TCP协议是在内核(传输层)中实现的，应用程序只能使用不能修改，如果要想升级TCP协议，那么只能升级内核。而升级内核这个工作是很麻烦的事情，麻烦的事情不是说升级内核这个操作很麻烦，而是由于内核升级涉及到底层软件和运行库的更新，我们的服务程序就需要回归测试是否兼容新的内核版本，所以服务器的内核升级也比较保守和缓慢。

即使TCP有比较好的特性更新，也很难快速推广，用户往往要几年或者十年才能体验到。

**<u>5）TCP的粘包问题</u>**

**<u>6）SYN泛洪攻击</u>**

**<u>7）ddos攻击</u>**

#### TCP粘包拆包，如何解决

**【TCP和UDP】**

- **TCP传输数据基于字节流**，从应用层到TCP传输层的多个数据包是一连串的字节流是没有边界的，而且**TCP首部并没有记录数据包的长度，所以TCP传输数据的时候可能会发生粘包和拆包的问题**
- **而UDP是基于数据报传输数据的**，是**面向报文的协议**，**UDP首部采用了16bit（2字节）来记录了数据报的长度**，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题

![image-20250324152408392](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324152408392.png)

**【粘包和拆包的原因】**

​	在发送端，当我们调用send函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是**从应用程序拷贝到了操作系统内核协议栈**中。至于什么时候真正被发送，**取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件**。

1)要发送的数据小于TCP发送缓冲区大小，TCP将多次写入缓冲区的数据一次发送出去，将发生粘包。

2)接收端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

3)要发送的数据大于TCP发送缓冲区的剩余空间，将会发生拆包

4)待发送数据大于最大报文长度，TCP将在传输前进行拆包。

**==【解决办法】==**

1**）发送端将每个数据包封装为固定长度（不够的可以通过补0填充）**

- 这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来；这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是某个字节a，当接收方接满某个字节a，就认为这个内容是一个完整且有效的消息
- 但是这种方式灵活性不高，实际中很少用

**2）可以在数据包之间设置边界，如添加特殊符号**

- 接收端通过这个边界就可以将不同的数据包拆分开。注意：这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据
  - Eg：**HTTP就是是一个例子**。HTTP通过设置回车符、换行符作为HTTP报文协议的边界。

3**）自定义消息结构，就是发送端给每个数据包添加包首部，首部中应该包含数据包的长度**，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。

#### SYN泛洪攻击及避免

​	TCP连接建立是需要三次握手，假设攻击者短时间伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但**服务端发送出去的ACK + SYN报文，无法得到未知IP主机的ACK应答，一直这样就会<font color = '#8D0101'>占满服务端的半连接队列（SYN队列）</font>，使得服务器不能为正常用户服务**。

**【正常流程】**

**<font color = '#8D0101'>Linux内核</font>的SYN队列（半连接队列）与Accpet队列（全连接队列）的工作流程**

- 当服务端接收到客户端的SYN报文时，会将其加入到内核的**「SYN队列」**；
- 接着发送SYN + ACK给客户端，等待客户端回应ACK报文；
- 服务端接收到ACK报文后，从「SYN队列」移除放入到**「Accept队列」**；
- 应用通过调用**accpet() socket接口**，从「Accept队列」取出连接。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250323201138834.png" alt="image-20250323201138834" style="zoom:50%;" />

**【如何避免SYN泛洪攻击】**

1） **降低SYN timeout时间**，使得主机尽快释放半连接的占用

2）其中一种解决方式是通过**修改Linux内核参数，控制队列大小和当队列满时应做什么处理**

3）如果不断受到SYN攻击，就会导致SYN队列（半连接队列）被占满，从而导致无法在建立新的连接，可以采用**SYN cookie设置(tcp_syncookies)来应对SYN攻击，就是如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文**。

4）采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击

#### ddos攻击以及避免

​	DDos攻击，全称是distributed denial of service，分布式拒绝服务，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为**分布式拒绝服务攻击**，其中的攻击者可以有多个。在线游戏、互联网金融等领域是DDos攻击的高发行业。

举个例子，一家火锅店里，50个座位，来了50个人找座位不点餐，让别的客人无法吃饭。

**【如何应对DDos攻击】**

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324155951440.png" alt="image-20250324155951440" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324160126144.png" alt="image-20250324160126144" style="zoom: 67%;" />

### TCP/IP与Socket的区别

![image-20251018234429574](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018234429574.png)

### Socket编程、自己实现TCP编程

#### 伪代码、整体流程

**1）服务端伪代码**

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps78.jpg) 

**2）客户端伪代码**

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps79.jpg) 



![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps80.jpg) 

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps81.jpg) 

​	这里需要注意的是，服务端调用accept时，连接成功了会返回一个已完成连接的socket，后续用来传输数据。

- 所以，**<font color = '#8D0101'>监听的socket和真正用来传送数据的socket，是「两个」socket，一个叫作监听socket，一个叫作已完成连接socket</font>。**
- 成功连接建立之后，双方开始通过read和write函数来读写数据，就像往一个文件流里面写东西一样。

#### 实例

**【服务端代码（Server.java）】**

```java
import java.io.*;
import java.net.*;

public class Server {
    public static void main(String[] args) {
        int port = 9999; // 监听的端口号

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("服务端已启动，等待客户端连接...");

            while (true) {
                // 等待客户端连接（阻塞方法）
                Socket clientSocket = serverSocket.accept();
                System.out.println("客户端已连接: " + clientSocket.getInetAddress());

                // 为每个客户端创建独立线程处理
                new Thread(new ClientHandler(clientSocket)).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 客户端处理线程
    private static class ClientHandler implements Runnable {
        private final Socket clientSocket;

        public ClientHandler(Socket socket) {
            this.clientSocket = socket;
        }

        @Override
        public void run() {
            try (
                BufferedReader in = new BufferedReader(
                    new InputStreamReader(clientSocket.getInputStream()));
                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)
            ) {
                String message;
                while ((message = in.readLine()) != null) {
                    System.out.println("收到客户端消息: " + message);
                    // 回显消息给客户端
                    out.println("服务端已收到: " + message);
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

【**客户端代码（Client.java）**】

```java
import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) {
        String serverAddress = "127.0.0.1"; // 服务端 IP 地址
        int port = 9999; // 服务端端口

        try (Socket socket = new Socket(serverAddress, port);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(
                 new InputStreamReader(socket.getInputStream()));
             BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) 
        {
            System.out.println("已连接到服务端，输入消息（输入 'exit' 退出）:");

            String userInput;
            while ((userInput = stdIn.readLine()) != null) {
                if ("exit".equalsIgnoreCase(userInput)) {
                    break;
                }
                // 发送消息到服务端
                out.println(userInput);
                // 读取服务端响应
                String response = in.readLine();
                System.out.println("服务端响应: " + response);
            }
        } catch (UnknownHostException e) {
            System.err.println("未知主机: " + serverAddress);
            e.printStackTrace();
        } catch (IOException e) {
            System.err.println("连接异常");
            e.printStackTrace();
        }
    }
}
```

1. **服务端**
   - 使用 `ServerSocket` 监听指定端口。
   - 每个客户端连接由独立线程处理（`ClientHandler`），支持多客户端并发。
   - 通过 `BufferedReader` 和 `PrintWriter` 读写文本数据。
2. **客户端**
   - 使用 `Socket` 连接到服务端的 IP 和端口。
   - 通过标准输入（`System.in`）读取消息，发送到服务端并接收响应。

## IP篇（网络层）

### IP基础知识

#### IP的基本认识

IP在TCP/IP参考模型中处于第三层，也就是**网络层。**

​	网络层的主要作用是：**实现主机与主机之间的通信，也叫点对点（end to end）通信**，**在复杂的网络环境中将数据包发给目的主机**

#### 网络层(IP)与数据链路层(MAC)有什么关系？

==**<font color = '#8D0101'>IP是大方向</font>，但每一步怎么走，还得靠MAC**==	

​	在上面我们知道IP的作用是主机之间通信用的，而**MAC的作用则是实现「直连」的两个设备之间通信，而IP则负责在「没有直连」的两个网络之间进行通信传输**。

​	意思是M**AC是负责某个区间的通信传输，比如说主机到路由器、路由器到路由器之间的通信，而IP则是负责将数据包发到最终的目的地址，比如说从一个主机A到另一个主机B**

​	还有重要一点，通信过程中虽然通信的工具不断变化，但是**通信的起始地址和目的地址始终都没变**。其实，在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用NAT网络），只有源MAC地址和目标MAC一直在变化**

#### IP地址概述

**IP地址（IPv4地址）由32位正整数来表示，IP地址在计算机是以二进制的方式处理的**。

​	而人类为了方便记忆采用了**点分十进制**的标记方式，也就是将32位IP地址以**每8位为组，共分为4组，每组以「.」隔开，再将每组转换成十进制**。

![image-20250324163525242](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163525242.png)

![image-20250324163542449](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163542449.png)

#### IP地址的分类

IP地址分类成了5种类型，分别是A类、B类、C类、D类、E类

![image-20250324163601753](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163601753.png)

##### A、B、C类地址

​	其中对于A、B、C类主要分为两个部分，分别是**网络号和主机号**。这很好理解，好比小林是A小区1栋101号，你是B小区1栋101号。

![image-20250324163638356](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163638356.png)

**【A、B、C分类地址最大主机个数是如何计算的】**

![image-20250324163712080](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163712080.png)

- **主机号全为1指定某个网络下的所有主机，用于广播**

- **主机号全为0指定某个网络**

  ![image-20250324163825828](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324163825828.png)

##### 广播地址用于什么？

广播地址用于在**同一个链路中相互连接的主机之间发送数据包**。

广播地址可以分为**本地广播和直接广播**两种

- **在本网络内广播的叫做本地广播**。例如网络地址为192.168.0.0/24的情况下，广播地址是192.168.0.255。因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.0/24以外的其他链路上。
- **在不同网络之间的广播叫做直接广播**。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。）

##### 127.0.0.1与0.0.0.0的区别

![image-20250324222525396](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324222525396.png)

##### 公有IP和私有IP

在A、B、C分类地址，实际上有分公有IP地址和私有IP地址。

![image-20250324224125592](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324224125592.png)

**【私有IP地址】**

![image-20250324224148669](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324224148669.png)

**【公有IP地址】**

公有IP地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有IP，这样全世界的人才能访问。并且**公有IP地址基本上要在整个互联网范围内保持唯一**。

#### 无分类地址CIDR

​	这种方式不再有分类地址的概念，32比特的IP地址被划分为两部分，**前面是网络号，后面是主机号**

##### 如何划分网络号和主机号

​	表示形式 `a.b.c.d/x`，其中**/x表示前×位属于网络号，×的范围是 0~32**，这就使得IP 地址更加具有灵活性.

- 比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24位是网络号，剩余的8位是主机号。

  ![image-20250324223135090](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223135090.png)

​	还有另一种划分网络号与主机号形式，那就是**<font color = '#8D0101'>子网掩码</font>**，掩码的意思就是**掩盖掉主机号，剩余的就是网络号**。

![image-20250324223241420](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223241420.png)

- ==将子网掩码和IP地址按位计算AND，就可得到网络号。==

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223327044.png" alt="image-20250324223327044" style="zoom:50%;" />

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223333215.png" alt="image-20250324223333215" style="zoom:50%;" />

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223338433.png" alt="image-20250324223338433" style="zoom:50%;" />

##### 为什么要分离网络号和主机号？

​	**因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同**，如果网络地址相同，表明接受方在本网络上，那么可以把致据包直接发送到目标主机。

​	路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223527802.png" alt="image-20250324223527802" style="zoom:60%;" />

##### 如何进行子网划分

可以通过**子网掩码划分出网络号和主机号**，那实际上**子网掩码还有一个作用，那就是<font color = '#8D0101'>划分子网</font>**

- 子网划分实际上是**将<font color = '#8D0101'>主机地址分为两个部分</font>**：**<font color = '#8D0101'>子网网络地址和子网主机地址</font>**，形式如下：
  - **未做子网划分的ip地址：网络地址＋主机地址**
  - **做子网划分后的ip地址：网络地址＋（子网网络地址＋子网主机地址）**![image-20250324223706559](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324223706559.png)

#### IP分片与重组

​	每种数据链路的**最大传输单元MTU**都是不相同的，如FDDI数据链路MTU 4352、以太网的MTU是1500字节等。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps89.jpg) 

- **<font color = '#8D0101'>当IP数据包大小大于MTU时，IP数据包就会被分片</font>**。
- **经过分片之后的IP数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的**。 

​	假设发送方发送一个4000字节的大数据报，若要传输在以太网链路，则需要把数据报分片成3个小数据报进行传输，再交由接收方重组成大数据报。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps90.jpg) 

> [!CAUTION]
>
> - 在分片传输中，一旦某个分片丢失，则会适成整个 IP 数据报作废，所以 **TCP 引入了MSS 也就是在 TCP 层进行分片不由IP 层分片**，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数撼报文。

#### IP地址和路由控制

IP地址的**网络地址**这一部分是用于进行**路由控制**

- **路由控制表中记录着网络地址与下一步应该发送至路由器的地址**。在主机和路由器上都会有各自的路由器控制表。
- 在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。**如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配**。

#### IPv4和IPv6的首部

![image-20251018234503104](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20251018234503104.png) 

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps93.jpg) 

Pv6相比IPv4的首部改进：

- 取消了首部校验和字段。因为在数据链路层和传输层都会校验，因此IPv6直接取消了IP的校验。
- 取消了分片/重新组装相关字段。分片与重组是耗时的过程，IPv6不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
- 取消选项字段。选项字段不再是标准IP首部的一部分了，但它并没有消失，而是可能出现在IPv6首部中的「下一个首部」指出的位置上。删除该选项字段使的IPv6的首部成为固定长度的40字节。

![image-20250324225006587](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324225006587.png)

### IP协议相关技术

#### IP地址与硬件地址的区别

**【IP地址】**

**1）IP地址是一种逻辑地址。**

2）IP地址称为逻辑地址，是因为IP地址是用软件实现的。

3）**IP地址是网络层及其以上各层(包括运输层、应用层等)使用的地址**。

**4）IP地址放在IP数据报的首部。**

**【硬件地址】**

**1）硬件地址是一种物理地址。**

2）硬件地址称为物理地址，是因为硬件地址是用硬件实现的。

3）**硬件地址是数据链路层和物理层使用的地址**。

**4）硬件地址放在MAC帧的首部。**

#### ==DNS（Domain Name System，域名系统）==

##### 域名、域名分级

**<font color = '#8D0101'>工作在应用层，主要用到的传输层协议是UDP,也用到了TCP，</font>**

​	DNS中的域名都是用句点来分隔的，比如www.server.com，这里的句点代表了不同层次之间的界限。

- **在域名中，越靠右的位置表示其层级越高**。根域是在最顶层，它的下一层就是com顶级域，再下面是server.com。

**域名的层级关系类似一个树状结构：**

- **根DNS服务器**

- **顶级域DNS服务器（com）**

- **权威DNS服务器（server.com）**

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324225303243.png" alt="image-20250324225303243" style="zoom:60%;" />

**（1）定义**

- **一级域名（顶级域名，TLD）（顶级域DNS服务器（com））**
  如 `.com`、`.org`、`.cn`，由 ICANN 管理，不可注册为个人使用。
- **二级域名（主域名）（权威DNS服务器（server.com））**
  用户可注册的部分，如 `example.com`。
- **三级域名（子域名）**
  在二级域名下创建，如 `www.example.com`、`api.example.com`。

**(2) 示例**

| 完整域名               | 级别     | 说明             |
| ---------------------- | -------- | ---------------- |
| `example.com`          | 二级域名 | 用户注册的主域名 |
| `www.example.com`      | 三级域名 | 常见的网站子域名 |
| `blog.api.example.com` | 四级域名 | 多级子域名       |

##### 域名解析的工作流程

==分为缓存查询和寻找域名服务器==

![image-20250324225450495](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324225450495.png)

![image-20250324225844121](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324225844121.png)

#### ARP(Address Resolution Protocol)

​	在传输一个IP数据报的时候，确定了源IP地址和目标IP地址后，就会**通过主机「路由表」确定IP数据包下一跳**。然而，**网络层的下一层是数据链路层**，所以我们还要**知道「下一跳」的<font color = '#8D0101'>MAC地址</font>**

​	由于主机的路由表中可以找到下一跳的IP地址，所以可以通过**<font color = '#8D0101'>ARP协议（根据IP找MAC）</font>**，求得下一跳的MAC地址。

**<u>1）ARP是如何知道对方MAC地址的呢？</u>**

简单地说，ARP是借助**ARP请求与ARP响应两种类型的包确定MAC地址的**。

- **主机会通过广播发送ARP请求**，这个包中**包含了想要知道的MAC地址的主机IP地址**。

- 当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，**如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的MAC地址塞入ARP响应包返回给主机**。

  ![image-20250324230257919](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324230257919.png)

**<u>2）RARP</u>**

ARP协议是已知IP地址求MAC地址，**那RARP协议正好相反，它是已知MAC地址求IP地址**

- 例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。

![image-20250324230340214](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324230340214.png)

#### NAT

网络地址转换技术，将私有IP地址转换为公有IP

![image-20250324230523389](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324230523389.png)

#### ICMP(应用层)

**ICMP全称是Internet Control Message Protocol，也就是互联网控制报文协议**

ICMP主要的功能包括：

- **确认IP包是否成功送达目标地址**
- **报告发送过程中IP包被废弃的原因**
- **改善网络设置等。**

​	在IP通信中如果**某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知**

【**ICMP大致可以分为两大类**】

- 一类是用于诊断的查询消息，也就是**「查询报文类型」**
- 一类是通知出错原因的错误消息，也就是**「差错报文类型」**

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324230739474.png" alt="image-20250324230739474" style="zoom:50%;" />

### ping的工作原理（基于ICMP的查询报文类型）(应用层)

- ICMP全称是**Internet Control Message Protocol**，也就是**互联网控制报文协议**
- ICMP主要的功能包括：**确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置**等。
- 在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个**具体的原因将由ICMP负责通知**

【**ICMP大致可以分为两大类**】

- 一类是用于诊断的查询消息，也就是**「查询报文类型」**
- 一类是通知出错原因的错误消息，也就是**「差错报文类型」**

**【PING——查询报文类型的使用】**

​	**查询报文**用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，**<font color = '#8D0101'>PING命令正是利用这个消息实现的</font>**。

- ping命令执行的时候，源主机首先会构建一个ICMP回送请求消息数据。

![image-20250324232156113](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324232156113.png)

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324232142725.png" alt="image-20250324232142725" style="zoom:80%;" />

## 网络综合篇

### URL**组成**

所以图中长长URL实际上是请求服务器里的文件资源。

- 当没有路径名时，就代表**访问根目承下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件**，这样就不会发生混乱了。

![image-20250324234407696](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324234407696.png)

![image-20250324234419073](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324234419073.png)

### URL和域名的区别

![image-20250324234544284](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324234544284.png)

### URI和URL的区别

- **URI**(Uniform Resource Identifier) 是**统一资源标志符**，可以唯一标识一个资源。
- **URL**(Uniform Resource Location) 是**统一资源定位符**，可以提供该资源的路径。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

​	**URI的作用像身份证号一样，URL的作用更像家庭住址一样**。**<font color = '#8D0101'>URL是一种具体的URI</font>**，它**不仅唯一标识资源，而且还提供了定位该资源的信息**。

### ==键入网址到网页显示，期间发生了什么==

![image-20250324234822125](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324234822125.png)

![image-20250324234840757](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324234840757.png)

![image-20250325155108069](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325155108069.png)

#### 1、(孤单小弟：HTTP)

​	浏览器做的第一步工作就是**解析URL**，解析完成后，浏览器**确定了Web服务器和文件名**，接下来就是**根据这些信息来生成HTTP请求消息**。

#### 2、(真实地址查询：DNS)

​	通过**浏览器解析URL并生成HTTP消息后**，需要**委托操作系统将消息发送给Web服务器**。但在发送之前，还有一项工作需要完成，那就是**<font color = '#8D0101'>查询服务器域名对应的IP地址</font>，因为委托操作系统发送消息时，必须提供通信对象的IP地址**。主要使用了DNS协议，DNS查询过程如下：

![image-20250324235006009](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324235006009.png)

#### 3、(指南好帮手：协议栈)

通过DNS获得IP后，就可以把**HTTP的传输工作交给操作系统中的协议栈**

它主要起到一个**指南**的作用，就是**接下来得用到什么协议等，比如TCP，IP、MAC等**。

**应用程序（浏览器）通过调用Socket库，来委托协议栈工作**。

- **协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议**，这两个传输协议会接受应用层的委托执行收发数据的操作。
- **协议栈的下面一半是用IP协议控制网络包收发操作**，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。
  - 此外IP中还包括**ICMP协议和ARP协议**。
    - ICMP用于告知网络包传送过程中产生的错误以及各种控制信息。
    - ARP用于根据IP地址查询相应的以太网MAC地址。

​	IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324235312039.png" alt="image-20250324235312039" style="zoom:55%;" />

> [!NOTE]
>
> （接下来就是去传输层、网络层、网络接口层，一层层包装，然后在以太网中通过交换机、路由器等发送到目标主机，然后再一层层拆包，到应用层拿到传输的数据，响应后原路返回。）

#### 4、(可靠传输：TCP)

​	==接下来就是一个TCP连接过程，**三次握手**。在**数据包（HTTP头部+数据）加上一个TCP头部**，但是**并不知道目的地在哪，即目标IP**==

​	可以介绍在**传输层中TCP协议对数据（如果大于MSS）进行分块**，然后加上TCP头部，甚至可以展开讲TCP头部都有啥，讲讲三次握手

- 在TCP协议里首先要有**源端口号和目标端口号**，如果没有这两个端口号，数据就不会知道应该发给哪个应用

![image-20250324235546242](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324235546242.png)

![image-20250324235613810](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250324235613810.png)

**【TCP报文生成】**

![image-20250325000213590](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000213590.png)

![image-20250325000027601](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000027601.png)

#### 5、(远程定位：IP)

接下来需要在**数据包装上IP的头部**，把它**封装成网络包发送给通信对象**。

在IP协议里面需要有**<font color = '#8D0101'>源地址IP和目标地址IP</font>**

- **源地址IP**，即是客**户端输出的IP地址**；
- **目标地址IP**，即通过**DNS域名解析得到的Web服务器IP**

**最后生成的IP报文：**

- 此时，加上了IP头部的数据包表示：“有IP大佬给我指路了，感谢IP层给我加上了IP包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000806479.png" alt="image-20250325000806479" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000811230.png" alt="image-20250325000811230" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000839179.png" alt="image-20250325000839179" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000913305.png" alt="image-20250325000913305" style="zoom:55%;" />

#### 6、两点传输：MAC

​	生成了IP头部之后，接下来网络包还需要在IP头部的前面加上MAC头部。**<font color = '#8D0101'>IP是大方向</font>，但每一步怎么走，还得靠MAC**。

- **MAC头部是以太网使用的头部**，在MAC包头里需要**<font color = '#8D0101'>发送方MAC地址和接收方目标MAC地址，用于两点之间的传输</font>**

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325153724589.png" alt="image-20250325153724589" style="zoom:25%;" />

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325153732016.png" alt="image-20250325153732016" style="zoom:25%;" />

  <img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325153739502.png" alt="image-20250325153739502" style="zoom:25%;" />

**【如何确认MAC发送方和接收方】**

![image-20250325153914430](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325153914430.png)

**1）先得搞清楚应该把包发给谁**

- **这个只要<font color = '#8D0101'>查一下路由表</font>就知道了**。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的IP 地址就可以了。

**2）接下来需要ARP协议找到接收方的MAC地址**

ARP是借助**ARP请求与ARP响应两种类型的包确定MAC地址的**。

- **主机会通过广播发送ARP请求**，这个包中**包含了想要知道的MAC地址的主机IP地址**。

- 当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，**如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的MAC地址塞入ARP响应包返回给主机**。

==**【最后生成的MAC报文】**==

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325154205821.png" alt="image-20250325154205821" style="zoom:62%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000806479.png" alt="image-20250325000806479" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000811230.png" alt="image-20250325000811230" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000839179.png" alt="image-20250325000839179" style="zoom:55%;" />

<img src="https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325000913305.png" alt="image-20250325000913305" style="zoom:55%;" />

![image-20250325154315997](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325154315997.png)

#### 7、出口：网卡

​	网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，**这才是真正的数据发送过程**。

![image-20250325154453444](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325154453444.png)

![image-20250325154459163](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325154459163.png)

#### 8、送别者：交换机

​	电信号会到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。然后通过包末尾的FCS校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。**<font color = '#8D0101'>交换机根据MAC地址表查找MAC地址，然后将信号发送到相应的端口</font>**。

![image-20250325154525874](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325154525874.png)

#### 9、出境大门：路由器

网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。

![img](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/wps94.jpg) 

- **路由器的端口都具有<font color = '#8D0101'>MAC地址</font>**，因此它就能够成为以太网的发送方和接收方；**<font color = '#8D0101'>同时还具有IP地址</font>**，从这个意义上来说，它和计算机的网卡是一样的。

**【转发包和接收包的过程】**

- 当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。
  - 路由器只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。
- 完成包接收操作之后，路由器就会**去掉包开头的MAC头部**。**根据MAC头部后方的IP头部中的内容进行包的转发操作**。

> [!CAUTION]
>
> - **<font color = '#8D0101'>MAC 头部的作用就是将包送达路由器</font>**，其中的**接收方 MAC地址就是路由器端口的 MAC地址**。因此，**当包到达路由器之后**，MAC 头部的任务就完成了，于是 **MAC 头部就会被丢弃**。
> - 在网络包传输的过程中，==源IP 和目标IP 始终是不会变的==，==一直变化的是 MAC地址==，因为**<font color = '#8D0101'>需要MAC地址在以太网内进行两个设备之间的包传输</font>**。

#### 10、互相拆包：服务器与客户端

数据包抵达服务器后，就开始扒开MAC头部、IP头部、TCP头部等

- 数据包抵达服务器后，（这里指的是先通过交换机转发到服务器端，这是网络接口层，交换机工作在这一层），所在的服务器会先扒开数据包的MAC头部（这是服务器端网络层做的事，路由器工作在这一层），查看是否和服务器自己的MAC地址符合，符合就将包收起来。
- 接着继续扒开数据包的IP头，发现IP地址符合，根据IP头中协议项，知道自己上层是TCP协议
- 扒开TCP的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。TCP头部里面还有端口号，HTTP的服务器正在监听这个端口号。
- 服务器自然就知道是HTTP进程想要这个包，于是就将包发给HTTP进程。
- 服务器的HTTP进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。
- HTTP响应报文也需要穿上TCP、IP、MAC头部，不过这次源地址是服务器IP地址，目的地址是客户端IP地址。
- 穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。
- 最后跳到了客户端的城门把守的路由器，路由器扒开IP头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。
- 客户端收到了服务器的响应数据包后，客户端开始扒皮，把收到的数据包的皮扒的剩HTTP响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！
- 最后，客户端要离开了，向服务器发起了TCP四次挥手，至此双方的连接就断开了

![image-20250325155500066](https://raw.githubusercontent.com/GLeXios/Notes/main/pics/image-20250325155500066.png)

# 